{
  "language": "Solidity",
  "sources": {
    "contracts/AccessoryLayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"./BaseIlluvitar.sol\";\r\nimport \"./DataTypes.sol\";\r\n\r\n/**\r\n * @title Accessory Layer\r\n * @dev inherit BaseIlluvitar\r\n * @author Dmitry Yakovlevich\r\n */\r\ncontract AccessoryLayer is BaseIlluvitar {\r\n    /// @dev Accessory Metadata struct\r\n    struct Metadata {\r\n        uint8 tier; // tier\r\n        AccessoryType accessoryType; // accessory type\r\n    }\r\n\r\n    /// @dev Accessory metadata\r\n    mapping(uint256 => Metadata) public metadata;\r\n\r\n    /**\r\n     * @notice Initialize Accessory NFT.\r\n     * @param name_ NFT Name.\r\n     * @param symbol_ NFT Symbol.\r\n     * @param imxMinter_ NFT Minter Address.\r\n     */\r\n    function initialize(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address imxMinter_\r\n    ) external initializer {\r\n        __BaseIlluvitar_init(name_, symbol_, imxMinter_);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint Accessory with blueprint.\r\n     * @dev blueprint has format of `abc`\r\n     *      a : box type\r\n            b : tier\r\n            c : accessory type\r\n     * @param to Recipient address\r\n     * @param tokenId Token id\r\n     * @param blueprint Accessory blueprint\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory blueprint\r\n    ) internal override {\r\n        _safeMint(to, tokenId);\r\n        (uint8 tier, AccessoryType accessoryType) = _parseBlueprint(blueprint);\r\n        metadata[tokenId] = Metadata({ tier: tier, accessoryType: accessoryType });\r\n        metadataInitialized[tokenId] = true;\r\n    }\r\n\r\n    /// @dev Parse blueprint\r\n    function _parseBlueprint(bytes memory blueprint) private pure returns (uint8 tier, AccessoryType accessoryType) {\r\n        uint8 j = 0;\r\n        uint8[] memory parsedData = new uint8[](2);\r\n\r\n        uint256 len = blueprint.length;\r\n        for (uint256 i = 0; i < len; i += 1) {\r\n            if (_isDecimal(blueprint[i])) {\r\n                parsedData[j] = uint8(blueprint[i]) - 0x30;\r\n                j += 1;\r\n            }\r\n        }\r\n        tier = parsedData[1];\r\n        accessoryType = AccessoryType(parsedData[2]);\r\n    }\r\n}\r\n"
    },
    "contracts/BaseIlluvitar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@imtbl/imx-contracts/contracts/IMintable.sol\";\nimport \"@imtbl/imx-contracts/contracts/utils/Minting.sol\";\n\n/**\n * @title BaseIlluvitar, this contract is inherited from OZ ERC721 contract,\n * @dev Inherit OZ ERC721Enumerable contract\n * @dev Use IMX minting model\n * @dev Contains base functions which can be used in Portrait Layer and Accessory Layer.\n * @author Dmitry Yakovlevich\n */\nabstract contract BaseIlluvitar is ERC721EnumerableUpgradeable, UUPSUpgradeable, OwnableUpgradeable, IMintable {\n    /// @dev Emitted when base URI is set.\n    event BaseUriUpdated(string baseUri);\n    /// @dev Emitted when sale status updated.\n    event OpenForSale(uint256 indexed tokenId, bool sale);\n\n    /// @dev IMX minter contract\n    address public imxMinter;\n    /// @dev Open for sale status\n    mapping(uint256 => bool) public openForSale;\n    /// @dev Metadata initialized status\n    mapping(uint256 => bool) public metadataInitialized;\n    /// @dev base URI\n    string internal __baseUri;\n\n    /**\n     * @dev Initialize Base Illuvitar.\n     * @param name_ NFT Name\n     * @param symbol_ NFT Symbol\n     * @param imxMinter_ IMX Minter Address\n     */\n    function __BaseIlluvitar_init(\n        string memory name_,\n        string memory symbol_,\n        address imxMinter_\n    ) internal initializer {\n        __ERC721_init(name_, symbol_);\n        __ERC721Enumerable_init();\n        __Ownable_init();\n\n        require(imxMinter_ != address(0), \"Minter cannot zero\");\n        imxMinter = imxMinter_;\n    }\n\n    /**\n     * @dev Set base URI\n     * @notice only owner can call this function.\n     * @param _baseUri_ base URI.\n     */\n    function setBaseUri(string memory _baseUri_) external onlyOwner {\n        __baseUri = _baseUri_;\n\n        emit BaseUriUpdated(_baseUri_);\n    }\n\n    /**\n     * @dev Mark for sale\n     * @notice Illuvitars cannot be used in game if they are open for sale\n     * @param tokenId tokenId\n     * @param _sale true or false\n     */\n    function markForSale(uint256 tokenId, bool _sale) external {\n        require(ownerOf(tokenId) == msg.sender, \"Not token owner\");\n        openForSale[tokenId] = _sale;\n        emit OpenForSale(tokenId, _sale);\n    }\n\n    /// Return baseURI\n    function _baseURI() internal view override returns (string memory) {\n        return __baseUri;\n    }\n\n    /**\n     * @dev Used to withdraw from IMX\n     * @param to Recipient address\n     * @param quantity quantity - must be 1\n     * @param mintingBlob IMX minting blob string - {tokenId:blueprint}\n     */\n    function mintFor(\n        address to,\n        uint256 quantity,\n        bytes calldata mintingBlob\n    ) external override {\n        require(quantity == 1, \"Amount must be 1\");\n        require(msg.sender == imxMinter, \"caller is not minter\");\n        (uint256 id, bytes memory blueprint) = Minting.split(mintingBlob);\n        _mint(to, id, blueprint);\n    }\n\n    /// @dev Checks if the byte1 represented character is a decimal number or not (base 10)\n    function _isDecimal(bytes1 char) internal pure returns (bool) {\n        return uint8(char) >= 0x30 && uint8(char) < 0x3A;\n    }\n\n    /// @dev Mint interface with blueprint\n    function _mint(\n        address to,\n        uint256 tokenId,\n        bytes memory blueprint\n    ) internal virtual;\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal virtual override onlyOwner {}\n\n    /// @dev UUPSUpgradeable storage gap\n    uint256[42] private __gap;\n}\n"
    },
    "contracts/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nenum AccessoryType {\r\n    Skin,\r\n    Body,\r\n    EyeWear,\r\n    HeadWear,\r\n    Props\r\n}\r\n\r\nenum BoxType {\r\n    Virtual,\r\n    Bronze,\r\n    Silver,\r\n    Gold,\r\n    Platinum,\r\n    Diamond\r\n}\r\n\r\nenum ExpressionType {\r\n    Normal,\r\n    ExpressionA,\r\n    ExpressionB\r\n}\r\n\r\nenum FinishType {\r\n    Normal,\r\n    Holo\r\n}\r\n\r\nenum BackgroundLine {\r\n    Dots,\r\n    Flash,\r\n    Hex,\r\n    Rain,\r\n    Spotlight,\r\n    Mozart,\r\n    Affinity,\r\n    Arena,\r\n    Token,\r\n    Encounter\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721Enumerable_init_unchained();\n    }\n\n    function __ERC721Enumerable_init_unchained() internal initializer {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal initializer {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@imtbl/imx-contracts/contracts/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMintable {\n    function mintFor(\n        address to,\n        uint256 quantity,\n        bytes calldata mintingBlob\n    ) external;\n}\n"
    },
    "@imtbl/imx-contracts/contracts/utils/Minting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Bytes.sol\";\n\nlibrary Minting {\n    // Split the minting blob into token_id and blueprint portions\n    // {token_id}:{blueprint}\n\n    function split(bytes calldata blob)\n        internal\n        pure\n        returns (uint256, bytes memory)\n    {\n        int256 index = Bytes.indexOf(blob, \":\", 0);\n        require(index >= 0, \"Separator must exist\");\n        // Trim the { and } from the parameters\n        uint256 tokenID = Bytes.toUint(blob[1:uint256(index) - 1]);\n        uint256 blueprintLength = blob.length - uint256(index) - 3;\n        if (blueprintLength == 0) {\n            return (tokenID, bytes(\"\"));\n        }\n        bytes calldata blueprint = blob[uint256(index) + 2:blob.length - 1];\n        return (tokenID, blueprint);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal initializer {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@imtbl/imx-contracts/contracts/utils/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary Bytes {\n    /**\n     * @dev Converts a `uint256` to a `string`.\n     * via OraclizeAPI - MIT licence\n     * https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n     */\n    function fromUint(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n\n    bytes constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(\n        bytes memory _base,\n        string memory _value,\n        uint256 _offset\n    ) internal pure returns (int256) {\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint256 i = _offset; i < _base.length; i++) {\n            if (_base[i] == _valueBytes[0]) {\n                return int256(i);\n            }\n        }\n\n        return -1;\n    }\n\n    function substring(\n        bytes memory strBytes,\n        uint256 startIndex,\n        uint256 endIndex\n    ) internal pure returns (string memory) {\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function toUint(bytes memory b) internal pure returns (uint256) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 val = uint256(uint8(b[i]));\n            if (val >= 48 && val <= 57) {\n                // input is 0-9\n                result = result * 10 + (val - 48);\n            } else {\n                // invalid character, expecting integer input\n                revert(\"invalid input, only numbers allowed\");\n            }\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/protocol/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"../chainlink/VRFConsumerBaseUpgradeable.sol\";\nimport \"../DataTypes.sol\";\nimport \"../interfaces/PriceOracleSpec.sol\";\n\n/**\n * @title Minter\n * @notice Allow users to request minting Illuvitars.\n * @dev Users can use ETH or sILV to request minting.\n * @dev Minter uses an chainlink VRF to genrate randomness.\n * @author Dmitry Yakovlevich\n */\ncontract Minter is VRFConsumerBaseUpgradeable, UUPSUpgradeable, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    uint16 private constant MAX_CHANCE = 10000; // 100%\n    uint8 private constant TIER_CHANCE_LEN = 4;\n    /// @dev expression count - Normal, Expression A, Expression B\n    uint8 private constant EXPRESSION_COUNT = 3;\n    uint8 private constant STAGE_COUNT = 3;\n    /// @dev 0: without accessory\n    ///      1: bonded 1 slot\n    ///      2: bonded 2 slot\n    ///      3: bonded 3 slot\n    ///      4: bonded 4 slot\n    ///      5: bonded 5 slot\n    uint8 private constant PORTRAIT_MASK = 6;\n\n    /// @dev Portrait mint information\n    mapping(BoxType => PortraitMintInfo) public portraitMintInfo;\n    /// @dev Accessory mint information\n    mapping(BoxType => AccessoryMintInfo) public accessoryMintInfo;\n    /// @dev expression probability\n    uint16[EXPRESSION_COUNT] private expressionProbability;\n    /// @dev stage probability\n    uint16[STAGE_COUNT] private stageProbability;\n\n    /// @dev Background tier chances\n    mapping(uint8 => mapping(BoxType => uint16[4])) public backgroundTierChances;\n    /// @dev Background line info per tier\n    mapping(uint8 => BackgroundLine[]) public backgroundLines;\n    /// @dev Background stages info per (tier, line)\n    mapping(uint8 => mapping(BackgroundLine => uint8[])) public backgroundStages;\n    /// @dev Background variation count per (tier, line, stage)\n    mapping(uint8 => mapping(BackgroundLine => mapping(uint8 => uint8))) public backgroundVariations;\n    /// @dev Illuvial count per tier\n    uint8[6] private illuvialCounts;\n\n    /// @dev User's mint requests\n    mapping(bytes32 => MintRequest) public mintRequests;\n    /// @dev User's free mint requests\n    mapping(uint256 => MintRequest) public freeRequests;\n    /// @dev Free requests count\n    uint256 public freeRequestCount;\n    /// @dev Portrait sale window\n    SaleWindow public portraitSaleWindow;\n\n    /// @dev sILV2 token address\n    address public sIlv;\n    /// @dev treasury address\n    address public treasury;\n    /// @dev ILV/ETH Chainlink price feed address\n    IlluvitarsPriceOracle public illuvitarsPriceOracle;\n    /// @dev chainlink VRF key hash\n    bytes32 private vrfKeyHash;\n    /// @dev chainlink VRF fee\n    uint256 private vrfFee;\n    /// @dev Next portrait token id to mint\n    uint256 private nextPortraitTokenId;\n    /// @dev Next accessory token id to mint\n    uint256 private nextAccessoryTokenId;\n    uint256 public freePortraitLimitPerTx;\n    uint256 public freeAccessoryLimitPerTx;\n\n    /* ======== EVENTS ======== */\n    /// @dev Emitted when treasury updated.\n    event TreasurySet(address indexed treasury);\n    /// @dev Emitted when user request mint.\n    event MintRequested(address indexed requester, bytes32 requestId);\n    /// @dev Emitted when user request free mint.\n    event FreeMintRequested(address indexed requester, uint256 idx);\n    /// @dev Emitted when chainlink fulfilled VRF request.\n    event RequestFulfilled(bytes32 indexed requestId, uint256 randomNumber);\n\n    /* ======== STRUCT ======== */\n    /// @dev Portrait mint params\n    struct PortraitMintParams {\n        BoxType boxType;\n        uint64 amount;\n    }\n\n    /// @dev Accessory semi random mint params\n    struct AccessorySemiRandomMintParams {\n        AccessoryType accessoryType;\n        BoxType boxType;\n        uint64 amount;\n    }\n\n    /// @dev Accessory full random mint params\n    struct AccessoryFullRandomMintParams {\n        BoxType boxType;\n        uint64 amount;\n    }\n\n    /// @dev User's mint request data\n    struct MintRequest {\n        address requester;\n        PortraitMintParams[] portraitMintParams;\n        uint256 portraitAmount; // total portrait amount\n        AccessorySemiRandomMintParams[] accessorySemiRandomMintParams;\n        AccessoryFullRandomMintParams[] accessoryFullRandomMintParams;\n        uint256 accessoryAmount; // total accessory amount\n        uint256 randomNumber; // random number from chainlink\n        uint256 portraitStartTokenId; // portrait start token id for this request\n        uint256 accessoryStartTokenId; // accessory start token id for this request\n    }\n\n    /// @dev Mintable portrait info\n    struct PortraitInfo {\n        uint256 tokenId;\n        BoxType boxType;\n        uint8 tier;\n        uint8 illuvial;\n        uint8 backgroundTier;\n        BackgroundLine backgroundLine;\n        uint8 backgroundStage;\n        uint8 backgroundVariation;\n        ExpressionType expression;\n        FinishType finish;\n    }\n\n    /// @dev Mintable accessory info\n    struct AccessoryInfo {\n        uint256 tokenId;\n        BoxType boxType;\n        AccessoryType accessoryType;\n        uint8 tier;\n        uint8 stage;\n    }\n\n    /// @dev Portrait price and tier pick chances for each box type\n    struct PortraitMintInfo {\n        uint256 price; // price\n        uint16[TIER_CHANCE_LEN] tierChances; // tier chances\n        uint16 holoProbability; // Holo probability\n    }\n\n    /// @dev Accessory semi and random price and tier pick chances for each box type\n    struct AccessoryMintInfo {\n        uint256 randomPrice; // full random price\n        uint256 semiRandomPrice; // semi random price\n        uint16[TIER_CHANCE_LEN] tierChances; // tier chances\n    }\n\n    /// @dev Sale window\n    struct SaleWindow {\n        uint64 start;\n        uint64 end;\n    }\n\n    /**\n     * @dev UUPSUpgradeable initializer\n     * @param _vrfCoordinator Chainlink VRF Coordinator address\n     * @param _linkToken LINK token address\n     * @param _vrfKeyhash Chainlink VRF Key Hash\n     * @param _vrfFee Chainlink VRF Fee\n     * @param _treasury Treasury address\n     * @param _sIlv sILV2 token address\n     * @param _illuvitarsPriceOracle ILV/ETH Chainlink price feed base illuvitars price oracle\n     */\n    function initialize(\n        address _vrfCoordinator,\n        address _linkToken,\n        bytes32 _vrfKeyhash,\n        uint256 _vrfFee,\n        address _treasury,\n        address _sIlv,\n        address _illuvitarsPriceOracle\n    ) external initializer {\n        require(\n            _treasury != address(0) && _illuvitarsPriceOracle != address(0) && _sIlv != address(0),\n            \"cannot zero address\"\n        );\n\n        __Ownable_init();\n        __VRFConsumerBase_init(_vrfCoordinator, _linkToken);\n\n        vrfKeyHash = _vrfKeyhash;\n        vrfFee = _vrfFee;\n        sIlv = _sIlv;\n        treasury = _treasury;\n        illuvitarsPriceOracle = IlluvitarsPriceOracle(_illuvitarsPriceOracle);\n        nextPortraitTokenId = 1;\n        nextAccessoryTokenId = 1;\n\n        _initializePortraitMintInfo();\n        _initializeAccessoryMintInfo();\n        _initializeBackgroundGenerationInfo();\n    }\n\n    /**\n     * @dev Set portrait sale window.\n     * @dev only owner can call this function.\n     * @param _saleWindow New sale window.\n     */\n    function setPortraitSaleWindow(SaleWindow calldata _saleWindow) external onlyOwner {\n        require(_saleWindow.start < _saleWindow.end, \"Invalid sale window\");\n        portraitSaleWindow = _saleWindow;\n    }\n\n    function setFreeMintLimitPerTx(uint256 _freePortraitLimitPerTx, uint256 _freeAccessoryLimitPerTx)\n        external\n        onlyOwner\n    {\n        freePortraitLimitPerTx = _freePortraitLimitPerTx;\n        freeAccessoryLimitPerTx = _freeAccessoryLimitPerTx;\n    }\n\n    /**\n     * @dev Set new treasury address.\n     * @dev only owner can call this function.\n     * @param treasury_ Treasury Address.\n     */\n    function setTreasury(address treasury_) external onlyOwner {\n        require(treasury_ != address(0), \"Treasury address cannot zero\");\n        treasury = treasury_;\n\n        emit TreasurySet(treasury_);\n    }\n\n    /**\n     * @dev Withdraw ether and sILV to treasury address.\n     * @dev only owner can call this function.\n     */\n    function withdraw() external onlyOwner {\n        uint256 etherBalance = address(this).balance;\n        if (etherBalance != 0) {\n            (bool success, ) = treasury.call{ value: etherBalance }(\"\");\n            require(success, \"Ether withdraw failed\");\n        }\n\n        uint256 sIlvBalance = IERC20Upgradeable(sIlv).balanceOf(address(this));\n        if (sIlvBalance != 0) {\n            IERC20Upgradeable(sIlv).safeTransfer(treasury, sIlvBalance);\n        }\n    }\n\n    /**\n     * @notice Mint for random accessory, callback for VRFConsumerBase\n     * @dev inaccessible from outside\n     * @param requestId requested random accesory Id.\n     * @param randomNumber Random Number.\n     */\n    function fulfillRandomness(bytes32 requestId, uint256 randomNumber) internal override {\n        require(mintRequests[requestId].requester != address(0), \"No request exist\");\n        require(mintRequests[requestId].randomNumber == 0, \"Random number already fulfilled\");\n\n        mintRequests[requestId].randomNumber = randomNumber;\n\n        emit RequestFulfilled(requestId, randomNumber);\n    }\n\n    /**\n     * @dev Request minting Portrait and Accesory NFTs.\n     * @notice Users pay ETH or sILV to request minting\n     * @param portraitMintParams portrait layer mint params.\n     * @param accessorySemiRandomMintParams accessory layer semi random mint params.\n     * @param accessoryFullRandomMintParams accessory layer full random mint params.\n     * @param useSIlv true to use sILV, false to use ETH.\n     */\n    function paidMint(\n        PortraitMintParams[] calldata portraitMintParams,\n        AccessorySemiRandomMintParams[] calldata accessorySemiRandomMintParams,\n        AccessoryFullRandomMintParams[] calldata accessoryFullRandomMintParams,\n        bool useSIlv\n    ) public payable {\n        uint256 etherPrice;\n\n        bytes32 requestId = requestRandomness(vrfKeyHash, vrfFee);\n\n        MintRequest storage mintRequest = mintRequests[requestId];\n        require(mintRequest.requester == address(0), \"Already requested\");\n        mintRequest.requester = msg.sender;\n\n        etherPrice = _storePortraitRequest(mintRequest, portraitMintParams, false);\n        etherPrice += _storeAccessoryRequest(\n            mintRequest,\n            accessorySemiRandomMintParams,\n            accessoryFullRandomMintParams,\n            false\n        );\n\n        if (etherPrice != 0) {\n            if (useSIlv) {\n                uint256 tokenAmount = uint256(illuvitarsPriceOracle.ethToIlv(etherPrice));\n                IERC20Upgradeable(sIlv).safeTransferFrom(msg.sender, address(this), tokenAmount);\n            }\n        }\n\n        emit MintRequested(msg.sender, requestId);\n    }\n\n    function _storePortraitRequest(\n        MintRequest storage mintRequest,\n        PortraitMintParams[] calldata portraitMintParams,\n        bool isFree\n    ) internal returns (uint256 etherPrice) {\n        uint256 length = portraitMintParams.length;\n        if (length > 0) {\n            require(\n                block.timestamp >= portraitSaleWindow.start && block.timestamp <= portraitSaleWindow.end,\n                \"Sale not started or ended\"\n            );\n        }\n\n        uint256 portraitAmount;\n        for (uint256 i = 0; i < length; i += 1) {\n            PortraitMintParams memory param = portraitMintParams[i];\n            require(param.amount != 0, \"Invalid amount\");\n            require(isFree == (param.boxType == BoxType.Virtual), \"Invalid box type\");\n            if (!isFree) {\n                etherPrice += uint256(param.amount) * portraitMintInfo[param.boxType].price;\n            }\n            portraitAmount += uint256(param.amount);\n            mintRequest.portraitMintParams.push(param);\n        }\n\n        require(!isFree || portraitAmount <= freePortraitLimitPerTx, \"Exceed limit\");\n\n        mintRequest.portraitAmount = portraitAmount;\n        mintRequest.portraitStartTokenId = nextPortraitTokenId;\n        nextPortraitTokenId += PORTRAIT_MASK * portraitAmount;\n    }\n\n    function _storeAccessoryRequest(\n        MintRequest storage mintRequest,\n        AccessorySemiRandomMintParams[] calldata accessorySemiRandomMintParams,\n        AccessoryFullRandomMintParams[] calldata accessoryFullRandomMintParams,\n        bool isFree\n    ) internal returns (uint256 etherPrice) {\n        uint256 length = accessorySemiRandomMintParams.length;\n\n        uint256 accessoryAmount;\n        for (uint256 i = 0; i < length; i += 1) {\n            AccessorySemiRandomMintParams memory param = accessorySemiRandomMintParams[i];\n            require(param.amount != 0, \"Invalid amount\");\n            require(isFree == (param.boxType == BoxType.Virtual), \"Invalid box type\");\n            if (!isFree) {\n                etherPrice += uint256(param.amount) * accessoryMintInfo[param.boxType].semiRandomPrice;\n            }\n            accessoryAmount += uint256(param.amount);\n            mintRequest.accessorySemiRandomMintParams.push(param);\n        }\n\n        length = accessoryFullRandomMintParams.length;\n        for (uint256 i = 0; i < length; i += 1) {\n            AccessoryFullRandomMintParams memory param = accessoryFullRandomMintParams[i];\n            require(param.amount != 0, \"Invalid amount\");\n            require(isFree == (param.boxType == BoxType.Virtual), \"Invalid box type\");\n            if (!isFree) {\n                etherPrice += uint256(param.amount) * accessoryMintInfo[param.boxType].randomPrice;\n            }\n            accessoryAmount += uint256(param.amount);\n            mintRequest.accessoryFullRandomMintParams.push(param);\n        }\n\n        require(!isFree || accessoryAmount <= freeAccessoryLimitPerTx, \"Exceed limit\");\n\n        mintRequest.accessoryAmount = accessoryAmount;\n        mintRequest.accessoryStartTokenId = nextAccessoryTokenId;\n        nextAccessoryTokenId += accessoryAmount;\n    }\n\n    /**\n     * @dev Request minting Portrait and Accesory NFTs.\n     * @notice Users pay ETH or sILV to request minting\n     * @param portraitMintParams portrait layer mint params.\n     * @param accessorySemiRandomMintParams accessory layer semi random mint params.\n     * @param accessoryFullRandomMintParams accessory layer full random mint params.\n     */\n    function freeMint(\n        PortraitMintParams[] calldata portraitMintParams,\n        AccessorySemiRandomMintParams[] calldata accessorySemiRandomMintParams,\n        AccessoryFullRandomMintParams[] calldata accessoryFullRandomMintParams\n    ) public {\n        MintRequest storage mintRequest = freeRequests[freeRequestCount];\n        mintRequest.requester = msg.sender;\n\n        _storePortraitRequest(mintRequest, portraitMintParams, true);\n        _storeAccessoryRequest(mintRequest, accessorySemiRandomMintParams, accessoryFullRandomMintParams, true);\n\n        emit FreeMintRequested(msg.sender, freeRequestCount);\n        freeRequestCount += 1;\n\n        mintRequest.randomNumber = uint256(keccak256(abi.encode(freeRequestCount, block.timestamp)));\n    }\n\n    /**\n     * @dev Get mintable portrait and accessory infos with chainlink random number\n     * @param requestId Request id of mint request.\n     * @return requester Requester address\n     * @return seed Seed random number from chainlink\n     * @return portraits Mintable portrait on-chain metadata\n     * @return accessories Mintable accessory on-chain metadata\n     */\n    function getPaidMintResult(bytes32 requestId)\n        external\n        view\n        returns (\n            address requester,\n            uint256 seed,\n            PortraitInfo[] memory portraits,\n            AccessoryInfo[] memory accessories\n        )\n    {\n        require(mintRequests[requestId].randomNumber != 0, \"No random number generated\");\n        MintRequest memory mintRequest = mintRequests[requestId];\n        requester = mintRequest.requester;\n        seed = mintRequest.randomNumber;\n\n        uint256 rand = seed;\n        if (mintRequest.portraitAmount != 0) {\n            (portraits, rand) = _getPortraitsInfo(\n                rand,\n                mintRequest.portraitMintParams,\n                mintRequest.portraitAmount,\n                mintRequest.portraitStartTokenId\n            );\n        }\n\n        if (\n            mintRequest.accessoryFullRandomMintParams.length > 0 || mintRequest.accessorySemiRandomMintParams.length > 0\n        ) {\n            accessories = _getAccessoriesInfo(\n                rand,\n                mintRequest.accessoryFullRandomMintParams,\n                mintRequest.accessorySemiRandomMintParams,\n                mintRequest.accessoryStartTokenId\n            );\n        }\n    }\n\n    function getFreeMintResult(uint256 idx)\n        external\n        view\n        returns (\n            address requester,\n            uint256 seed,\n            PortraitInfo[] memory portraits,\n            AccessoryInfo[] memory accessories\n        )\n    {\n        MintRequest memory mintRequest = freeRequests[idx];\n        requester = mintRequest.requester;\n        require(requester != address(0), \"No request\");\n        seed = mintRequest.randomNumber;\n\n        uint256 rand = seed;\n        if (mintRequest.portraitAmount > 0) {\n            (portraits, rand) = _getPortraitsInfo(\n                rand,\n                mintRequest.portraitMintParams,\n                mintRequest.portraitAmount,\n                mintRequest.portraitStartTokenId\n            );\n        }\n\n        if (\n            mintRequest.accessoryFullRandomMintParams.length > 0 || mintRequest.accessorySemiRandomMintParams.length > 0\n        ) {\n            accessories = _getAccessoriesInfo(\n                rand,\n                mintRequest.accessoryFullRandomMintParams,\n                mintRequest.accessorySemiRandomMintParams,\n                mintRequest.accessoryStartTokenId\n            );\n        }\n    }\n\n    /**\n     * @dev Internal method to get mintable portrait infos\n     * @param seed Seed random number to generate portrait infos\n     * @param portraitMintParams Users portrait mint params\n     * @return portraits Mintable portrait on-chain metadata\n     * @return nextRand Last random number to generate accessory metadata\n     */\n    function _getPortraitsInfo(\n        uint256 seed,\n        PortraitMintParams[] memory portraitMintParams,\n        uint256 portraitAmount,\n        uint256 startTokenId\n    ) internal view returns (PortraitInfo[] memory portraits, uint256 nextRand) {\n        uint256 length = portraitMintParams.length;\n\n        uint256 tokenId = startTokenId;\n        nextRand = seed;\n\n        portraits = new PortraitInfo[](portraitAmount);\n        uint256 idx;\n\n        for (uint256 i = 0; i < length; i += 1) {\n            PortraitMintParams memory mintParam = portraitMintParams[i];\n            uint256 amount = mintParam.amount;\n\n            for (uint256 j = 0; j < amount; j += 1) {\n                (portraits[idx], nextRand, tokenId) = _getPortraitInfo(nextRand, mintParam, tokenId);\n                idx += 1;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal method to get portrait info\n     * @param rand Random number\n     * @param mintParam Portrait mint params\n     * @param tokenId token id\n     * @return portrait Mintable portrait on-chain metadata\n     * @return nextRand Next random number\n     * @return nextTokenId Next item token id\n     */\n    function _getPortraitInfo(\n        uint256 rand,\n        PortraitMintParams memory mintParam,\n        uint256 tokenId\n    )\n        internal\n        view\n        returns (\n            PortraitInfo memory portrait,\n            uint256 nextRand,\n            uint256 nextTokenId\n        )\n    {\n        uint256 _rand;\n\n        portrait.tokenId = tokenId;\n        portrait.boxType = mintParam.boxType;\n        uint8 tier;\n        if (mintParam.boxType == BoxType.Virtual) {\n            _rand = rand;\n        } else {\n            uint16 chance;\n            (_rand, chance) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n            tier = _getTier(portraitMintInfo[mintParam.boxType].tierChances, chance);\n            portrait.tier = tier;\n            (_rand, portrait.backgroundTier) = _getBackgroundTier(tier, mintParam.boxType, _rand);\n        }\n\n        (_rand, portrait.illuvial) = _getQuotientAndRemainder8(_rand, illuvialCounts[tier]);\n\n        uint8 backgroundIdx;\n        (_rand, backgroundIdx) = _getQuotientAndRemainder8(\n            _rand,\n            uint8(backgroundLines[portrait.backgroundTier].length)\n        );\n        portrait.backgroundLine = backgroundLines[portrait.backgroundTier][backgroundIdx];\n\n        (_rand, backgroundIdx) = _getQuotientAndRemainder8(\n            _rand,\n            uint8(backgroundStages[portrait.backgroundTier][portrait.backgroundLine].length)\n        );\n        portrait.backgroundStage = backgroundStages[portrait.backgroundTier][portrait.backgroundLine][backgroundIdx];\n\n        (_rand, portrait.backgroundVariation) = _getQuotientAndRemainder8(\n            _rand,\n            backgroundVariations[portrait.backgroundTier][portrait.backgroundLine][portrait.backgroundStage]\n        );\n\n        (_rand, portrait.expression) = _getExpression(_rand);\n        (, portrait.finish) = _getFinish(_rand, mintParam.boxType);\n\n        nextTokenId = tokenId + PORTRAIT_MASK;\n        nextRand = uint256(keccak256(abi.encode(rand, rand)));\n    }\n\n    /**\n     * @dev Internal method to get semi accessory info\n     * @param rand Random number\n     * @param mintParam Accessory semi mint params\n     * @param tokenId token id\n     * @return accessory Mintable accessory on-chain metadata\n     * @return nextRand Next random number\n     * @return nextTokenId Next item token id\n     */\n    function _getSemiAcccessoryInfo(\n        uint256 rand,\n        AccessorySemiRandomMintParams memory mintParam,\n        uint256 tokenId\n    )\n        internal\n        view\n        returns (\n            AccessoryInfo memory accessory,\n            uint256 nextRand,\n            uint256 nextTokenId\n        )\n    {\n        uint256 _rand;\n\n        accessory.tokenId = tokenId;\n        accessory.boxType = mintParam.boxType;\n        accessory.accessoryType = mintParam.accessoryType;\n        uint8 tier;\n        if (mintParam.boxType == BoxType.Virtual) {\n            _rand = rand;\n        } else {\n            uint16 chance;\n            (_rand, chance) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n            tier = _getTier(accessoryMintInfo[mintParam.boxType].tierChances, chance);\n            accessory.tier = tier;\n        }\n\n        (, accessory.stage) = _getAccessoryStage(_rand);\n\n        nextTokenId = tokenId + 1;\n        nextRand = uint256(keccak256(abi.encode(rand, rand)));\n    }\n\n    /**\n     * @dev Internal method to get full accessory info\n     * @param rand Random number\n     * @param mintParam Accessory full mint params\n     * @param tokenId token id\n     * @return accessory Mintable accessory on-chain metadata\n     * @return nextRand Next random number\n     * @return nextTokenId Next item token id\n     */\n    function _getFullAcccessoryInfo(\n        uint256 rand,\n        AccessoryFullRandomMintParams memory mintParam,\n        uint256 tokenId\n    )\n        internal\n        view\n        returns (\n            AccessoryInfo memory accessory,\n            uint256 nextRand,\n            uint256 nextTokenId\n        )\n    {\n        uint256 _rand;\n\n        accessory.tokenId = tokenId;\n        accessory.boxType = mintParam.boxType;\n        uint8 tier;\n        if (mintParam.boxType == BoxType.Virtual) {\n            _rand = rand;\n        } else {\n            uint16 chance;\n            (_rand, chance) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n            tier = _getTier(accessoryMintInfo[mintParam.boxType].tierChances, chance);\n            accessory.tier = tier;\n        }\n\n        accessory.accessoryType = AccessoryType(uint8(_rand % 5));\n\n        (, accessory.stage) = _getAccessoryStage(_rand);\n\n        nextTokenId = tokenId + 1;\n        nextRand = uint256(keccak256(abi.encode(rand, rand)));\n    }\n\n    /**\n     * @dev Internal method to get mintable accessories infos\n     * @param seed Seed random number to generate portrait infos\n     * @param fullRandomMintParams Users accessory full mint params\n     * @param semiRandomMintParams Users accessory semi mint params\n     * @return accessories Mintable accessory on-chain metadata\n     */\n    function _getAccessoriesInfo(\n        uint256 seed,\n        AccessoryFullRandomMintParams[] memory fullRandomMintParams,\n        AccessorySemiRandomMintParams[] memory semiRandomMintParams,\n        uint256 startTokenId\n    ) internal view returns (AccessoryInfo[] memory accessories) {\n        uint256 fullRandomAmount;\n        uint256 semiRandomAmount;\n        uint256 length = fullRandomMintParams.length;\n        for (uint256 i = 0; i < length; i += 1) {\n            fullRandomAmount += fullRandomMintParams[i].amount;\n        }\n\n        uint256 tokenId = startTokenId;\n        length = semiRandomMintParams.length;\n        for (uint256 i = 0; i < length; i += 1) {\n            semiRandomAmount += semiRandomMintParams[i].amount;\n        }\n\n        uint256 idx;\n        uint256 nextRand = seed;\n        accessories = new AccessoryInfo[](semiRandomAmount + fullRandomAmount);\n\n        for (uint256 i = 0; i < length; i += 1) {\n            AccessorySemiRandomMintParams memory mintParam = semiRandomMintParams[i];\n            uint256 amount = mintParam.amount;\n            for (uint256 j = 0; j < amount; j += 1) {\n                (accessories[idx], nextRand, tokenId) = _getSemiAcccessoryInfo(nextRand, mintParam, tokenId);\n                idx += 1;\n            }\n        }\n\n        length = fullRandomMintParams.length;\n        for (uint256 i = 0; i < length; i += 1) {\n            AccessoryFullRandomMintParams memory mintParam = fullRandomMintParams[i];\n            uint256 amount = mintParam.amount;\n            for (uint256 j = 0; j < amount; j += 1) {\n                (accessories[idx], nextRand, tokenId) = _getFullAcccessoryInfo(nextRand, mintParam, tokenId);\n                idx += 1;\n            }\n        }\n    }\n\n    function setPortraitMintInfo(BoxType boxType, PortraitMintInfo memory mintInfo) external onlyOwner {\n        require(boxType != BoxType.Virtual, \"Cannot set virtual info\");\n        _validateTierChances(mintInfo.tierChances);\n\n        portraitMintInfo[boxType] = mintInfo;\n    }\n\n    function setAccessoryMintInfo(BoxType boxType, AccessoryMintInfo memory mintInfo) external onlyOwner {\n        require(boxType != BoxType.Virtual, \"Cannot set virtual info\");\n        _validateTierChances(mintInfo.tierChances);\n\n        accessoryMintInfo[boxType] = mintInfo;\n    }\n\n    function _validateTierChances(uint16[TIER_CHANCE_LEN] memory tierChances) internal pure {\n        for (uint256 i = 0; i < TIER_CHANCE_LEN - 1; i += 1) {\n            require(tierChances[i] <= tierChances[i + 1], \"Invalid tier chance\");\n        }\n        require(tierChances[TIER_CHANCE_LEN - 1] <= MAX_CHANCE, \"Invalid tier chance\");\n    }\n\n    /**\n     * @dev Initialize portrait mint information\n     * @notice Price and tier chances are constant\n     */\n    function _initializePortraitMintInfo() internal {\n        expressionProbability = [5000, 8000, 10000];\n        illuvialCounts = [3, 6, 5, 4, 4, 3];\n    }\n\n    /**\n     * @dev Initialize accessory mint information\n     * @notice Price and tier chances are constant\n     */\n    function _initializeAccessoryMintInfo() internal {\n        stageProbability = [4500, 8000, 10000];\n    }\n\n    /**\n     * @dev Initialize background tier chances\n     */\n    function _initializeBackgroundGenerationInfo() internal {\n        // tier 1\n        backgroundTierChances[1][BoxType.Bronze] = [6457, 9201, 9758, 9919];\n        backgroundTierChances[1][BoxType.Silver] = [3948, 7443, 9191, 9838];\n        backgroundTierChances[1][BoxType.Gold] = [1067, 4800, 7733, 9333];\n        backgroundTierChances[1][BoxType.Platinum] = [143, 1000, 2929, 7500];\n        backgroundTierChances[1][BoxType.Diamond] = [48, 435, 1525, 3946];\n\n        // tier 2\n        backgroundTierChances[2][BoxType.Bronze] = [8700, 9624, 9874, 9956];\n        backgroundTierChances[2][BoxType.Silver] = [6912, 8442, 9462, 9887];\n        backgroundTierChances[2][BoxType.Gold] = [2775, 5203, 7746, 9307];\n        backgroundTierChances[2][BoxType.Platinum] = [385, 962, 2693, 7308];\n        backgroundTierChances[2][BoxType.Diamond] = [126, 378, 1324, 3690];\n\n        // tier 3\n        backgroundTierChances[3][BoxType.Bronze] = [8636, 9859, 9942, 9978];\n        backgroundTierChances[3][BoxType.Silver] = [7248, 9387, 9743, 9941];\n        backgroundTierChances[3][BoxType.Gold] = [3512, 7610, 8683, 9561];\n        backgroundTierChances[3][BoxType.Platinum] = [750, 2250, 3375, 7375];\n        backgroundTierChances[3][BoxType.Diamond] = [253, 928, 1561, 3671];\n\n        // tier 4\n        backgroundTierChances[4][BoxType.Bronze] = [8499, 9854, 9976, 9989];\n        backgroundTierChances[4][BoxType.Silver] = [7042, 9380, 9899, 9971];\n        backgroundTierChances[4][BoxType.Gold] = [3416, 7900, 9466, 9786];\n        backgroundTierChances[4][BoxType.Platinum] = [1081, 3513, 5945, 8107];\n        backgroundTierChances[4][BoxType.Diamond] = [428, 1711, 3315, 4652];\n\n        // tier 5\n        backgroundTierChances[5][BoxType.Bronze] = [8402, 9830, 9975, 9996];\n        backgroundTierChances[5][BoxType.Silver] = [6846, 9270, 9876, 9988];\n        backgroundTierChances[5][BoxType.Gold] = [3200, 7680, 9440, 9920];\n        backgroundTierChances[5][BoxType.Platinum] = [1000, 3400, 6100, 9300];\n        backgroundTierChances[5][BoxType.Diamond] = [535, 2246, 4652, 7326];\n\n        // background line, stage, variation info\n        backgroundLines[0] = [BackgroundLine.Dots];\n        backgroundStages[0][BackgroundLine.Dots] = [1];\n        backgroundVariations[0][BackgroundLine.Dots][1] = 10;\n\n        backgroundLines[1] = [BackgroundLine.Flash];\n        backgroundStages[1][BackgroundLine.Flash] = [1];\n        backgroundVariations[1][BackgroundLine.Flash][1] = 10;\n\n        backgroundLines[2] = [BackgroundLine.Hex, BackgroundLine.Rain];\n        backgroundStages[2][BackgroundLine.Hex] = [2];\n        backgroundStages[2][BackgroundLine.Rain] = [3];\n        backgroundVariations[2][BackgroundLine.Hex][2] = 8;\n        backgroundVariations[2][BackgroundLine.Rain][3] = 8;\n\n        backgroundLines[3] = [BackgroundLine.Spotlight, BackgroundLine.Mozart];\n        backgroundStages[3][BackgroundLine.Spotlight] = [3];\n        backgroundStages[3][BackgroundLine.Mozart] = [2];\n        backgroundVariations[3][BackgroundLine.Spotlight][3] = 5;\n        backgroundVariations[3][BackgroundLine.Mozart][2] = 8;\n\n        backgroundLines[4] = [BackgroundLine.Affinity, BackgroundLine.Arena];\n        backgroundStages[4][BackgroundLine.Affinity] = [1];\n        backgroundStages[4][BackgroundLine.Arena] = [1];\n        backgroundVariations[4][BackgroundLine.Affinity][1] = 5;\n        backgroundVariations[4][BackgroundLine.Arena][1] = 2;\n\n        backgroundLines[5] = [BackgroundLine.Token, BackgroundLine.Encounter];\n        backgroundStages[5][BackgroundLine.Token] = [1, 2];\n        backgroundStages[5][BackgroundLine.Encounter] = [3];\n        backgroundVariations[5][BackgroundLine.Token][1] = 1;\n        backgroundVariations[5][BackgroundLine.Token][2] = 1;\n        backgroundVariations[5][BackgroundLine.Encounter][3] = 2;\n    }\n\n    function _getTier(uint16[TIER_CHANCE_LEN] memory tierChances, uint16 chance) internal pure returns (uint8) {\n        for (uint8 k = 0; k < TIER_CHANCE_LEN; k += 1) {\n            if (tierChances[k] > chance) {\n                return k + 1;\n            }\n        }\n        return TIER_CHANCE_LEN + 1;\n    }\n\n    function _getBackgroundTier(\n        uint8 tier,\n        BoxType boxType,\n        uint256 rand\n    ) internal view returns (uint256 newRand, uint8 backgroundTier) {\n        if (boxType == BoxType.Virtual) {\n            return (rand, 0);\n        }\n\n        uint16 chance;\n        (newRand, chance) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n\n        uint16[TIER_CHANCE_LEN] memory chances = backgroundTierChances[tier][boxType];\n\n        for (uint8 k = 0; k < TIER_CHANCE_LEN; k += 1) {\n            if (chances[k] > chance) {\n                backgroundTier = k + 1;\n                break;\n            }\n        }\n        backgroundTier = TIER_CHANCE_LEN + 1;\n    }\n\n    function _getExpression(uint256 rand) internal view returns (uint256 newRand, ExpressionType expression) {\n        uint16 value;\n        (newRand, value) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n\n        for (uint8 i = 0; i < EXPRESSION_COUNT; i += 1) {\n            if (value < expressionProbability[i]) {\n                expression = ExpressionType(i);\n                break;\n            }\n        }\n    }\n\n    function _getFinish(uint256 rand, BoxType boxType) internal view returns (uint256 newRand, FinishType finish) {\n        uint16 holoProbability = boxType == BoxType.Virtual ? 200 : portraitMintInfo[boxType].holoProbability;\n        uint16 value;\n        (newRand, value) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n\n        if (value <= holoProbability) {\n            finish = FinishType.Holo;\n        } else {\n            finish = FinishType.Normal;\n        }\n    }\n\n    function _getAccessoryStage(uint256 rand) internal view returns (uint256 newRand, uint8 stage) {\n        uint16 value;\n        (newRand, value) = _getQuotientAndRemainder16(rand, MAX_CHANCE);\n\n        for (uint8 i = 0; i < STAGE_COUNT; i += 1) {\n            if (value < stageProbability[i]) {\n                stage = i + 1;\n                break;\n            }\n        }\n    }\n\n    /// @dev calculate quotient and remainder\n    function _getQuotientAndRemainder16(uint256 a, uint16 b) internal pure returns (uint256, uint16) {\n        return (a / b, uint16(a % b));\n    }\n\n    /// @dev calculate quotient and remainder\n    function _getQuotientAndRemainder8(uint256 a, uint8 b) internal pure returns (uint256, uint8) {\n        return (a / b, uint8(a % b));\n    }\n\n    /// @inheritdoc UUPSUpgradeable\n    function _authorizeUpgrade(address) internal virtual override onlyOwner {}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/chainlink/VRFConsumerBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title VRFConsumerBaseUpgradeable\n * @dev Has same functionality as Chainlink VRFConsumerBase.sol, but used for upgradeable\n */\nabstract contract VRFConsumerBaseUpgradeable is Initializable, VRFRequestIDBase {\n    /**\n     * @notice fulfillRandomness handles the VRF response. Your contract must\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n     * @notice principles to keep in mind when implementing your fulfillRandomness\n     * @notice method.\n     *\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\n     * @dev signature, and will call it once it has verified the proof\n     * @dev associated with the randomness. (It is triggered via a call to\n     * @dev rawFulfillRandomness, below.)\n     *\n     * @param requestId The Id initially returned by requestRandomness\n     * @param randomness the VRF output\n     */\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n    /**\n     * @dev In order to keep backwards compatibility we have kept the user\n     * seed field around. We remove the use of it because given that the blockhash\n     * enters later, it overrides whatever randomness the used seed provides.\n     * Given that it adds no security, and can easily lead to misunderstandings,\n     * we have removed it from usage and can now provide a simpler API.\n     */\n    uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n    /**\n     * @notice requestRandomness initiates a request for VRF output given _seed\n     *\n     * @dev The fulfillRandomness method receives the output, once it's provided\n     * @dev by the Oracle, and verified by the vrfCoordinator.\n     *\n     * @dev The _keyHash must already be registered with the VRFCoordinator, and\n     * @dev the _fee must exceed the fee specified during registration of the\n     * @dev _keyHash.\n     *\n     * @dev The _seed parameter is vestigial, and is kept only for API\n     * @dev compatibility with older versions. It can't *hurt* to mix in some of\n     * @dev your own randomness, here, but it's not necessary because the VRF\n     * @dev oracle will mix the hash of the block containing your request into the\n     * @dev VRF seed it ultimately uses.\n     *\n     * @param _keyHash ID of public key against which randomness is generated\n     * @param _fee The amount of LINK to send with the request\n     *\n     * @return requestId unique ID for this request\n     *\n     * @dev The returned requestId can be used to distinguish responses to\n     * @dev concurrent requests. It is passed as the first argument to\n     * @dev fulfillRandomness.\n     */\n    function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\n        // the hash of the block containing this request to obtain the seed/input\n        // which is finally passed to the VRF cryptographic machinery.\n        uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n        // nonces[_keyHash] must stay in sync with\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n        // This provides protection against the user repeating their input seed,\n        // which would result in a predictable/duplicate output, if multiple such\n        // requests appeared in the same block.\n        nonces[_keyHash] = nonces[_keyHash] + 1;\n        return makeRequestId(_keyHash, vRFSeed);\n    }\n\n    LinkTokenInterface internal LINK;\n    address private vrfCoordinator;\n\n    // Nonces for each VRF key from which randomness has been requested.\n    //\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\n    mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n        private nonces;\n\n    /**\n     * @param _vrfCoordinator address of VRFCoordinator contract\n     * @param _link address of LINK token contract\n     *\n     * @dev https://docs.chain.link/docs/link-token-contracts\n     */\n    function __VRFConsumerBase_init(address _vrfCoordinator, address _link) internal initializer {\n        vrfCoordinator = _vrfCoordinator;\n        LINK = LinkTokenInterface(_link);\n    }\n\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n    // the origin of the call\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n        require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n        fulfillRandomness(requestId, randomness);\n    }\n}\n"
    },
    "contracts/interfaces/PriceOracleSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Pair Price Oracle, a.k.a. Pair Oracle\n *\n * @notice Generic interface used to consult on the Uniswap-like token pairs conversion prices;\n *      one pair oracle is used to consult on the exchange rate within a single token pair\n *\n * @notice See also: https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/building-an-oracle\n *\n * @author Basil Gorin\n */\ninterface PairOracle {\n    /**\n     * @notice Updates the oracle with the price values if required, for example\n     *      the cumulative price at the start and end of a period, etc.\n     *\n     * @dev This function is part of the oracle maintenance flow\n     */\n    function update() external;\n\n    /**\n     * @notice For a pair of tokens A/B (sell/buy), consults on the amount of token B to be\n     *      bought if the specified amount of token A to be sold\n     *\n     * @dev This function is part of the oracle usage flow\n     *\n     * @param token token A (token to sell) address\n     * @param amountIn amount of token A to sell\n     * @return amountOut amount of token B to be bought\n     */\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\n}\n\n/**\n * @title Price Oracle Registry\n *\n * @notice To make pair oracles more convenient to use, a more generic Oracle Registry\n *        interface is introduced: it stores the addresses of pair price oracles and allows\n *        searching/querying for them\n *\n * @author Basil Gorin\n */\ninterface PriceOracleRegistry {\n    /**\n     * @notice Searches for the Pair Price Oracle for A/B (sell/buy) token pair\n     *\n     * @param tokenA token A (token to sell) address\n     * @param tokenB token B (token to buy) address\n     * @return pairOracle pair price oracle address for A/B token pair\n     */\n    function getPriceOracle(address tokenA, address tokenB) external view returns (address pairOracle);\n}\n\n/**\n * @title Illuvitars Price Oracle\n *\n * @notice Supports the Illuvitars with the ETH/ILV conversion required,\n *       marker interface is required to support ERC165 lookups\n *\n * @author Basil Gorin\n */\ninterface IlluvitarsPriceOracle {\n    /**\n     * @notice Powers the ETH/ILV illuvitar token price conversion, used when\n     *      selling the illuvitar for sILV to determine how much sILV to accept\n     *      instead of the nominated ETH price\n     *\n     * @notice Note that sILV price is considered to be equal to ILV price\n     *\n     * @dev Implementation must guarantee not to return zero, absurdly small\n     *      or big values, it must guarantee the price is up to date with some\n     *      reasonable update interval threshold\n     *\n     * @param ethOut amount of ETH sale contract is expecting to get\n     * @return ilvIn amount of sILV sale contract should accept instead\n     */\n    function ethToIlv(uint256 ethOut) external view returns (uint256 ilvIn);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "contracts/protocol/IlluvitarsPriceOracleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC165Spec.sol\";\nimport \"../interfaces/PriceOracleSpec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title Chainlink Price Feed Aggregator based Illuvitars Price Oracle\n *\n * @notice IlluvitarsPriceOracle implementation based on ILV/ETH Chainlink price feeds,\n *      see https://docs.chain.link/docs/ethereum-addresses/\n *      see https://docs.chain.link/docs/using-chainlink-reference-contracts/\n *\n * @author Basil Gorin\n */\ncontract IlluvitarsPriceOracleV1 is ERC165, IlluvitarsPriceOracle, UpgradeableAccessControl {\n    /**\n     * @notice Chainlink ILV/ETH price feed aggregator maintains ILV/ETH price feed\n     */\n    AggregatorV3Interface public aggregator;\n\n    /**\n     * @notice When communicating with Chainlink ILV/ETH price feed, we verify how old\n     *      the IV/ETH price is, and if it is older than `oldAnswerThreshold`, the answer\n     *      is treated as old and is not used: `ethToIlv` conversion function throws in this case\n     */\n    uint256 public oldAnswerThreshold;\n\n    /**\n     * @notice Price Oracle manager is responsible for updating `oldAnswerThreshold` value,\n     *      and other price oracle configuration values in the future\n     *\n     * @dev Role ROLE_PRICE_ORACLE_MANAGER allows updating the `oldAnswerThreshold` value\n     *      (executing `setOldAnswerThreshold` function)\n     */\n    uint32 public constant ROLE_PRICE_ORACLE_MANAGER = 0x0001_0000;\n\n    /**\n     * @dev Fired in setOldAnswerThreshold()\n     *\n     * @param _by an address which executed update\n     * @param _oldVal old oldAnswerThreshold value\n     * @param _newVal new oldAnswerThreshold value\n     */\n    event OldAnswerThresholdUpdated(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n    /**\n     * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n     *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n     *\n     * @param _aggregator Chainlink ILV/ETH price feed aggregator address\n     */\n    function initialize(address _aggregator) public virtual initializer {\n        // verify the inputs are set\n        require(_aggregator != address(0), \"aggregator address is not set\");\n\n        // assign the addresses\n        aggregator = AggregatorV3Interface(_aggregator);\n\n        // set the default value for the threshold\n        oldAnswerThreshold = 30 hours;\n\n        // verify the inputs are valid smart contracts of the expected interfaces\n        // since Chainlink AggregatorV3Interface doesn't support ERC165, verify\n        // by executing the functions we're going to use anyway\n        // get the data\n        uint8 decimals = aggregator.decimals();\n        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = aggregator\n            .latestRoundData();\n        // verify the response\n        require(\n            decimals > 0 && roundId > 0 && answer > 0 && startedAt > 0 && updatedAt > 0 && answeredInRound > 0,\n            \"unexpected aggregator response\"\n        );\n\n        // execute all parent initializers in cascade\n        UpgradeableAccessControl._postConstruct(msg.sender);\n    }\n\n    /**\n     * @notice Restricted access function to update `oldAnswerThreshold` value, used\n     *       in `ethToIlv` conversion function to determine if Chainlink ILV/ETH price feed\n     *       returns the value fresh enough to be used\n     *\n     * @notice Note: `ethToIlv` conversion function throws if Chainlink ILV/ETH price feed\n     *      answer is older then `oldAnswerThreshold` value\n     *\n     * @notice Chainlink is expected to update ILV/ETH price at least one per day (24 hours)\n     *      therefore `oldAnswerThreshold` should be kept bigger than 24 hours\n     *\n     * @param _oldAnswerThreshold `oldAnswerThreshold` value to set\n     */\n    function setOldAnswerThreshold(uint256 _oldAnswerThreshold) public {\n        // verify the access permission\n        require(isSenderInRole(ROLE_PRICE_ORACLE_MANAGER), \"access denied\");\n\n        // check that the value supplied resides in a reasonable bounds\n        require(_oldAnswerThreshold > 1 hours, \"threshold too low\");\n        require(_oldAnswerThreshold < 7 days, \"threshold too high\");\n\n        // emit an event first - to log both old and new values\n        emit OldAnswerThresholdUpdated(msg.sender, oldAnswerThreshold, _oldAnswerThreshold);\n\n        // update the `oldAnswerThreshold` value\n        oldAnswerThreshold = _oldAnswerThreshold;\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n        // determine and return the interface support\n        return interfaceID == type(IlluvitarsPriceOracle).interfaceId;\n    }\n\n    /**\n     * @inheritdoc IlluvitarsPriceOracle\n     */\n    function ethToIlv(uint256 ethOut) public view virtual override returns (uint256 ilvIn) {\n        // get the latest round data from Chainlink price feed aggregator\n        // see https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata\n        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = aggregator\n            .latestRoundData();\n\n        // verify if the data obtained from Chainlink looks fresh, updated recently\n        // TODO: review and check with Chainlink this is a correct way of ensuring data freshness\n        require(roundId == answeredInRound && startedAt <= updatedAt && updatedAt <= now256(), \"invalid answer\");\n        require(updatedAt > now256() - oldAnswerThreshold, \"answer is too old\");\n\n        // calculate according to `ethOut * ilvIn / ethOut` formula and return\n        return (ethOut * 10**aggregator.decimals()) / uint256(answer);\n    }\n\n    /**\n     * @dev Testing time-dependent functionality may be difficult;\n     *      we override time in the helper test smart contract (mock)\n     *\n     * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n     */\n    function now256() public view virtual returns (uint256) {\n        // return current block timestamp\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwiener, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     *\n     * @dev Interface identification is specified in ERC-165.\n     *      This function uses less than 30,000 gas.\n     *\n     * @param interfaceID The interface identifier, as specified in ERC-165\n     * @return `true` if the contract implements `interfaceID` and\n     *      `interfaceID` is not 0xffffffff, `false` otherwise\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Access Control List // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\n    /**\n     * @notice Privileged addresses with defined roles/permissions\n     * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n     *      allow minting or burning tokens, transferring on behalf and so on\n     *\n     * @dev Maps user address to the permissions bitmask (role), where each bit\n     *      represents a permission\n     * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n     *      represents all possible permissions\n     * @dev 'This' address mapping represents global features of the smart contract\n     */\n    mapping(address => uint256) public userRoles;\n\n    /**\n     * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n     *      the amount of storage used by a contract always adds up to the 50.\n     *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Access manager is responsible for assigning the roles to users,\n     *      enabling/disabling global features of the smart contract\n     * @notice Access manager can add, remove and update user roles,\n     *      remove and update global features\n     *\n     * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n     * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n     */\n    uint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n     * @notice Upgrade manager is responsible for smart contract upgrades,\n     *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n     *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n     *\n     * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n     * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n     */\n    uint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n     * @dev Bitmask representing all the possible permissions (super admin role)\n     * @dev Has all the bits are enabled (2^256 - 1 value)\n     */\n    uint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max;\n\n    /**\n     * @dev Fired in updateRole() and updateFeatures()\n     *\n     * @param _by operator which called the function\n     * @param _to address which was granted/revoked permissions\n     * @param _requested permissions requested\n     * @param _actual permissions effectively set\n     */\n    event RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n    /**\n     * @dev UUPS initializer, sets the contract owner to have full privileges\n     *\n     * @param _owner smart contract owner having full privileges\n     */\n    function _postConstruct(address _owner) internal virtual initializer {\n        // grant owner full privileges\n        userRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n        // fire an event\n        emit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n    }\n\n    /**\n     * @notice Returns an address of the implementation smart contract,\n     *      see ERC1967Upgrade._getImplementation()\n     *\n     * @return the current implementation address\n     */\n    function getImplementation() public view virtual returns (address) {\n        // delegate to `ERC1967Upgrade._getImplementation()`\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Retrieves globally set of features enabled\n     *\n     * @dev Effectively reads userRoles role for the contract itself\n     *\n     * @return 256-bit bitmask of the features enabled\n     */\n    function features() public view returns (uint256) {\n        // features are stored in 'this' address  mapping of `userRoles` structure\n        return userRoles[address(this)];\n    }\n\n    /**\n     * @notice Updates set of the globally enabled features (`features`),\n     *      taking into account sender's permissions\n     *\n     * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n     * @dev Function is left for backward compatibility with older versions\n     *\n     * @param _mask bitmask representing a set of features to enable/disable\n     */\n    function updateFeatures(uint256 _mask) public {\n        // delegate call to `updateRole`\n        updateRole(address(this), _mask);\n    }\n\n    /**\n     * @notice Updates set of permissions (role) for a given user,\n     *      taking into account sender's permissions.\n     *\n     * @dev Setting role to zero is equivalent to removing an all permissions\n     * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n     *      copying senders' permissions (role) to the user\n     * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n     *\n     * @param operator address of a user to alter permissions for or zero\n     *      to alter global features of the smart contract\n     * @param role bitmask representing a set of permissions to\n     *      enable/disable for a user specified\n     */\n    function updateRole(address operator, uint256 role) public {\n        // caller must have a permission to update user roles\n        require(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n        // evaluate the role and reassign it\n        userRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n        // fire an event\n        emit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n    }\n\n    /**\n     * @notice Determines the permission bitmask an operator can set on the\n     *      target permission set\n     * @notice Used to calculate the permission bitmask to be set when requested\n     *     in `updateRole` and `updateFeatures` functions\n     *\n     * @dev Calculated based on:\n     *      1) operator's own permission set read from userRoles[operator]\n     *      2) target permission set - what is already set on the target\n     *      3) desired permission set - what do we want set target to\n     *\n     * @dev Corner cases:\n     *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n     *        `desired` bitset is returned regardless of the `target` permission set value\n     *        (what operator sets is what they get)\n     *      2) Operator with no permissions (zero bitset):\n     *        `target` bitset is returned regardless of the `desired` value\n     *        (operator has no authority and cannot modify anything)\n     *\n     * @dev Example:\n     *      Consider an operator with the permissions bitmask     00001111\n     *      is about to modify the target permission set          01010101\n     *      Operator wants to set that permission set to          00110011\n     *      Based on their role, an operator has the permissions\n     *      to update only lowest 4 bits on the target, meaning that\n     *      high 4 bits of the target set in this example is left\n     *      unchanged and low 4 bits get changed as desired:      01010011\n     *\n     * @param operator address of the contract operator which is about to set the permissions\n     * @param target input set of permissions to operator is going to modify\n     * @param desired desired set of permissions operator would like to set\n     * @return resulting set of permissions given operator will set\n     */\n    function evaluateBy(\n        address operator,\n        uint256 target,\n        uint256 desired\n    ) public view returns (uint256) {\n        // read operator's permissions\n        uint256 p = userRoles[operator];\n\n        // taking into account operator's permissions,\n        // 1) enable the permissions desired on the `target`\n        target |= p & desired;\n        // 2) disable the permissions desired on the `target`\n        target &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n        // return calculated result\n        return target;\n    }\n\n    /**\n     * @notice Checks if requested set of features is enabled globally on the contract\n     *\n     * @param required set of features to check against\n     * @return true if all the features requested are enabled, false otherwise\n     */\n    function isFeatureEnabled(uint256 required) public view returns (bool) {\n        // delegate call to `__hasRole`, passing `features` property\n        return __hasRole(features(), required);\n    }\n\n    /**\n     * @notice Checks if transaction sender `msg.sender` has all the permissions required\n     *\n     * @param required set of permissions (role) to check against\n     * @return true if all the permissions requested are enabled, false otherwise\n     */\n    function isSenderInRole(uint256 required) public view returns (bool) {\n        // delegate call to `isOperatorInRole`, passing transaction sender\n        return isOperatorInRole(msg.sender, required);\n    }\n\n    /**\n     * @notice Checks if operator has all the permissions (role) required\n     *\n     * @param operator address of the user to check role for\n     * @param required set of permissions (role) to check\n     * @return true if all the permissions requested are enabled, false otherwise\n     */\n    function isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n        // delegate call to `__hasRole`, passing operator's permissions (role)\n        return __hasRole(userRoles[operator], required);\n    }\n\n    /**\n     * @dev Checks if role `actual` contains all the permissions required `required`\n     *\n     * @param actual existent role\n     * @param required required role\n     * @return true if actual has required role (all permissions), false otherwise\n     */\n    function __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n        // check the bitmask for the role required and return the result\n        return actual & required == required;\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address) internal virtual override {\n        // caller must have a permission to upgrade the contract\n        require(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/mock/ChainlinkAggregatorV3Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title Chainlink Price Feed Aggregator V3 Mock\n *\n * @notice Supports the Illuvitars Price Oracle with the ILV/ETH price feed\n *\n * @dev Enables testing of the feed, playing with current timestamp\n *\n * @author Basil Gorin\n */\ncontract ChainlinkAggregatorV3Mock is AggregatorV3Interface {\n    // values returned by `latestRoundData()`\n    uint80 public roundIdMocked = 1;\n    int256 public answerMocked = -1;\n    uint256 public startedAtMocked = type(uint256).max;\n    uint256 public updatedAtMocked = type(uint256).max;\n    uint80 public answeredInRoundMocked = 1;\n    // answer (conversion rate) is derived from the ILV/ETH ratio\n    // initial conversion rate is 1 ETH = 4 ILV\n    uint256 public ethOut = 1;\n    uint256 public ilvIn = 4;\n\n    /// @dev overridden value to use as now32()\n    uint256 private _now256;\n\n    /// @dev overrides now256()\n    function setNow256(uint256 value) public {\n        _now256 = value;\n    }\n\n    /**\n     * @dev Testing time-dependent functionality may be difficult;\n     *      we override time in the helper test smart contract (mock)\n     *\n     * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n     */\n    function now256() public view returns (uint256) {\n        return _now256 > 0 ? _now256 : block.timestamp;\n    }\n\n    /**\n     * @dev Overrides roundId, answer, startedAt, updatedAt, answeredInRound\n     */\n    function setMockedValues(\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) public {\n        roundIdMocked = roundId;\n        answerMocked = answer;\n        startedAtMocked = startedAt;\n        updatedAtMocked = updatedAt;\n        answeredInRoundMocked = answeredInRound;\n    }\n\n    // updates the conversion rate\n    function setRate(uint256 _ethOut, uint256 _ilvIn) public {\n        ethOut = _ethOut;\n        ilvIn = _ilvIn;\n    }\n\n    /**\n     * @inheritdoc AggregatorV3Interface\n     */\n    function decimals() public pure override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @inheritdoc AggregatorV3Interface\n     */\n    function description() public pure override returns (string memory) {\n        return \"ILV / ETH (Mock!)\";\n    }\n\n    /**\n     * @inheritdoc AggregatorV3Interface\n     */\n    function version() public pure override returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @inheritdoc AggregatorV3Interface\n     */\n    function getRoundData(uint80 _roundId)\n        public\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        require(_roundId == roundIdMocked, \"roundId differs from the roundId mocked value\");\n        return latestRoundData();\n    }\n\n    /**\n     * @inheritdoc AggregatorV3Interface\n     */\n    function latestRoundData()\n        public\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (\n            roundIdMocked,\n            answerMocked >= 0 ? answerMocked : int256((10**decimals() * ethOut) / ilvIn),\n            startedAtMocked < type(uint256).max ? startedAtMocked : now256(),\n            updatedAtMocked < type(uint256).max ? updatedAtMocked : now256(),\n            answeredInRoundMocked\n        );\n    }\n}\n"
    },
    "contracts/PortraitLayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.14;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"./BaseIlluvitar.sol\";\nimport \"./DataTypes.sol\";\n\n/**\n * @title Portrait Layer\n * @dev inherit BaseIlluvitar\n * @author Dmitry Yakovlevich\n */\ncontract PortraitLayer is BaseIlluvitar {\n    /// @dev Portrait Metadata struct\n    struct Metadata {\n        uint8 tier; // tier\n        // Bonded accessory token ids\n        uint256 skinId; // bonded skin id\n        uint256 bodyId; // bonded body id\n        uint256 eyeId; // bonded eye wear id\n        uint256 headId; // bonded head wear id\n        uint256 propsId; // bonded props id\n    }\n\n    /// @dev Portrait metadata\n    mapping(uint256 => Metadata) public metadata;\n\n    /**\n     * @dev Initialize Portrait Layer.\n     * @param name_ NFT Name\n     * @param symbol_ NFT Symbol\n     * @param imxMinter_ IMX Minter Address\n     */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address imxMinter_\n    ) external initializer {\n        __BaseIlluvitar_init(name_, symbol_, imxMinter_);\n    }\n\n    /**\n     * @dev Mint Portrait with blueprint.\n     * @dev blueprint has format of `a,b,c,d,e,f`\n     *      a : tier\n            b : bonded skin id\n            c : bonded body id\n            d : bonded eye wear id\n            e : bonded head wear id\n            f : bonded props id\n     * @param to Recipient address\n     * @param tokenId Token id\n     * @param blueprint Portrait blueprint\n     */\n    function _mint(\n        address to,\n        uint256 tokenId,\n        bytes memory blueprint\n    ) internal override {\n        _safeMint(to, tokenId);\n        (\n            uint8 tier,\n            uint256 skinTokenId,\n            uint256 bodyTokenId,\n            uint256 eyeTokenId,\n            uint256 headTokenId,\n            uint256 propsTokenId\n        ) = _parseBlueprint(blueprint);\n        metadata[tokenId] = Metadata({\n            tier: tier,\n            skinId: skinTokenId,\n            bodyId: bodyTokenId,\n            eyeId: eyeTokenId,\n            headId: headTokenId,\n            propsId: propsTokenId\n        });\n        metadataInitialized[tokenId] = true;\n    }\n\n    /// @dev Parse blueprint\n    function _parseBlueprint(bytes memory blueprint)\n        private\n        pure\n        returns (\n            uint8 tier,\n            uint256 skinTokenId,\n            uint256 bodyTokenId,\n            uint256 eyeTokenId,\n            uint256 headTokenId,\n            uint256 propsTokenId\n        )\n    {\n        uint256 len = blueprint.length;\n        uint8 p;\n\n        p = _skipNonDecimal(blueprint, p);\n        require(_isDecimal(blueprint[p + 1]), \"Wrong blueprint format\");\n        tier = uint8(blueprint[p++]) - 0x30;\n        (skinTokenId, p) = _atoi(blueprint, p);\n        (bodyTokenId, p) = _atoi(blueprint, p);\n        (eyeTokenId, p) = _atoi(blueprint, p);\n        (headTokenId, p) = _atoi(blueprint, p);\n        (propsTokenId, p) = _atoi(blueprint, p);\n        p = _skipNonDecimal(blueprint, p);\n        require(p == len, \"Wrong blueprint format\");\n    }\n\n    /**\n     * @dev Skip non-decimal characters and return the index of the first decimal\n     *\n     * @dev If no decimal character is present, it will return the length of `a`\n     *\n     * @param a numeric string to convert\n     * @param offset an index to start parsing from, set to zero to parse from the beginning\n     * @return p an index where the conversion stopped\n     */\n    function _skipNonDecimal(bytes memory a, uint8 offset) internal pure returns (uint8 p) {\n        // skip wrong characters in the beginning of the string if any\n        for (p = offset; p < a.length; p++) {\n            // check if digit is valid and meets the base 10\n            if (_isDecimal(a[p])) {\n                // we've found decimal character, skipping stops\n                return p;\n            }\n        }\n        return p;\n    }\n\n    /**\n     * @dev Simplified version of StringUtils.atoi to convert a bytes string\n     *      to unsigned integer using ten as a base\n     * @dev Stops on invalid input (wrong character for base ten) and returns\n     *      the position within a string where the wrong character was encountered\n     *\n     * @dev Throws if input string contains a number bigger than uint256\n     *\n     * @param a numeric string to convert\n     * @param offset an index to start parsing from, set to zero to parse from the beginning\n     * @return i a number representing given string\n     * @return p an index where the conversion stopped\n     */\n    function _atoi(bytes memory a, uint8 offset) internal pure returns (uint256 i, uint8 p) {\n        // skip wrong characters in the beginning of the string if any\n        p = _skipNonDecimal(a, offset);\n\n        // iterate over the rest of the string (bytes buffer)\n        for (; p < a.length; p++) {\n            // check if digit is valid and meets the base 10\n            if (!_isDecimal(a[p])) {\n                // we've found bad character, parsing stops\n                break;\n            }\n\n            // move to the next digit slot\n            i *= 10;\n\n            // extract the digit and add it to the result\n            i += uint8(a[p]) - 0x30;\n        }\n\n        // return the result\n        return (i, p);\n    }\n}\n"
    },
    "contracts/mock/AccessControlMocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Upgradeable Access Control Mock\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock is UpgradeableAccessControl {\n    // v1 identifier\n    string public v1;\n\n    /**\n     * @dev UUPS initializer, sets the contract owner to have full privileges\n     *\n     * param _owner smart contract owner having full privileges\n     */\n    function postConstruct() public virtual initializer {\n        // execute parent initializer\n        _postConstruct(msg.sender);\n\n        // self init\n        v1 = \"v1\";\n    }\n}\n\n/**\n * @title Upgradeable Access Control Mock 2\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock2 is UpgradeableAccessControlMock {\n    // v2 identifier\n    string public v2;\n\n    /**\n     * @dev UUPS initializer, sets the contract owner to have full privileges\n     *\n     * param _owner smart contract owner having full privileges\n     */\n    function postConstruct() public virtual override initializer {\n        // execute parent initializer\n        _postConstruct(msg.sender);\n\n        // self init\n        v2 = \"v2\";\n    }\n}\n"
    },
    "contracts/mock/IlluvitarsPriceOracleV1Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/IlluvitarsPriceOracleV1.sol\";\n\n/**\n * @title Chainlink Illuvitars Price Oracle Mock\n *\n * @notice Supports theIlluvitars with the ETH/ILV conversion required\n *\n * @dev Enables oracle price override, playing with current timestamp\n *\n * @author Basil Gorin\n */\ncontract IlluvitarsPriceOracleV1Mock is IlluvitarsPriceOracleV1 {\n    // override the value calculated based on the feed\n    uint256 public ethToIlvOverride;\n\n    /// @dev overridden value to use as now32()\n    uint256 private _now256;\n\n    /// @dev overrides now256()\n    function setNow256(uint256 value) public {\n        _now256 = value;\n    }\n\n    /**\n     * @inheritdoc IlluvitarsPriceOracleV1\n     */\n    function initialize(address _aggregator) public override initializer {\n        super.initialize(_aggregator);\n        ethToIlvOverride = type(uint256).max;\n    }\n\n    /**\n     * @dev Testing time-dependent functionality may be difficult;\n     *      we override time in the helper test smart contract (mock)\n     *\n     * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n     */\n    function now256() public view override returns (uint256) {\n        return _now256 > 0 ? _now256 : super.now256();\n    }\n\n    // overrides the `ethToIlv` completely and forces it to always return the value specified\n    function setEthToIlvOverride(uint256 _ethToIlvOverride) public {\n        ethToIlvOverride = _ethToIlvOverride;\n    }\n\n    /**\n     * @inheritdoc IlluvitarsPriceOracle\n     */\n    function ethToIlv(uint256 _ethOut) public view virtual override returns (uint256 _ilvIn) {\n        return ethToIlvOverride < type(uint256).max ? ethToIlvOverride : super.ethToIlv(_ethOut);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}