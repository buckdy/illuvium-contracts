{
  "language": "Solidity",
  "sources": {
    "contracts/AccessoryLayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"./BaseIlluvitar.sol\";\r\nimport \"./DataTypes.sol\";\r\n\r\n/**\r\n * @title Accessory Layer\r\n * @dev inherit BaseIlluvitar\r\n * @author Dmitry Yakovlevich\r\n */\r\ncontract AccessoryLayer is BaseIlluvitar {\r\n    /// @dev Accessory Metadata struct\r\n    struct Metadata {\r\n        BoxType boxType; // box type\r\n        uint8 tier; // tier\r\n        AccessoryType accessoryType; // accessory type\r\n    }\r\n\r\n    /// @dev Accessory metadata\r\n    mapping(uint256 => Metadata) public metadata;\r\n\r\n    /**\r\n     * @notice Initialize Accessory NFT.\r\n     * @param name_ NFT Name.\r\n     * @param symbol_ NFT Symbol.\r\n     * @param imxMinter_ NFT Minter Address.\r\n     */\r\n    function initialize(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address imxMinter_\r\n    ) external initializer {\r\n        __BaseIlluvitar_init(name_, symbol_, imxMinter_);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint Accessory with blueprint.\r\n     * @dev blueprint has format of `abc`\r\n     *      a : box type\r\n            b : tier\r\n            c : accessory type\r\n     * @param to Recipient address\r\n     * @param tokenId Token id\r\n     * @param blueprint Accessory blueprint\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory blueprint\r\n    ) internal override {\r\n        _safeMint(to, tokenId);\r\n        if (!metadataInitialized[tokenId]) {\r\n            (BoxType boxType, uint8 tier, AccessoryType accessoryType) = _parseBlueprint(blueprint);\r\n            metadata[tokenId] = Metadata({ boxType: boxType, tier: tier, accessoryType: accessoryType });\r\n            metadataInitialized[tokenId] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev Parse blueprint\r\n    function _parseBlueprint(bytes memory blueprint)\r\n        private\r\n        pure\r\n        returns (\r\n            BoxType boxType,\r\n            uint8 tier,\r\n            AccessoryType accessoryType\r\n        )\r\n    {\r\n        uint8 j = 0;\r\n        uint8[] memory parsedData = new uint8[](3);\r\n\r\n        uint256 len = blueprint.length;\r\n        for (uint256 i = 0; i < len; i += 1) {\r\n            if (_isDecimal(blueprint[i])) {\r\n                parsedData[j] = uint8(blueprint[i]) - 0x30;\r\n                j += 1;\r\n            }\r\n        }\r\n        boxType = BoxType(parsedData[0]);\r\n        tier = parsedData[1];\r\n        accessoryType = AccessoryType(parsedData[2]);\r\n    }\r\n}\r\n"
    },
    "contracts/BaseIlluvitar.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@imtbl/imx-contracts/contracts/IMintable.sol\";\r\nimport \"@imtbl/imx-contracts/contracts/utils/Minting.sol\";\r\n\r\n/**\r\n * @title BaseIlluvitar, this contract is inherited from OZ ERC721 contract,\r\n * @dev Inherit OZ ERC721Enumerable contract\r\n * @dev Use IMX minting model\r\n * @dev Contains base functions which can be used in Portrait Layer and Accessory Layer.\r\n * @author Dmitry Yakovlevich\r\n */\r\nabstract contract BaseIlluvitar is ERC721EnumerableUpgradeable, UUPSUpgradeable, OwnableUpgradeable, IMintable {\r\n    /// @dev Emitted when base URI is set.\r\n    event BaseUriUpdated(string baseUri);\r\n    /// @dev Emitted when sale status updated.\r\n    event OpenForSale(uint256 indexed tokenId, bool sale);\r\n\r\n    /// @dev IMX minter contract\r\n    address public imxMinter;\r\n    /// @dev Open for sale status\r\n    mapping(uint256 => bool) public openForSale;\r\n    /// @dev Metadata initialized status\r\n    mapping(uint256 => bool) public metadataInitialized;\r\n    /// @dev base URI\r\n    string internal __baseUri;\r\n\r\n    /**\r\n     * @dev Initialize Base Illuvitar.\r\n     * @param name_ NFT Name\r\n     * @param symbol_ NFT Symbol\r\n     * @param imxMinter_ IMX Minter Address\r\n     */\r\n    function __BaseIlluvitar_init(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address imxMinter_\r\n    ) internal initializer {\r\n        __ERC721_init(name_, symbol_);\r\n        __ERC721Enumerable_init();\r\n        __Ownable_init();\r\n\r\n        require(imxMinter_ != address(0), \"Minter cannot zero\");\r\n        imxMinter = imxMinter_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set base URI\r\n     * @notice only owner can call this function.\r\n     * @param _baseUri_ base URI.\r\n     */\r\n    function setBaseUri(string memory _baseUri_) external onlyOwner {\r\n        __baseUri = _baseUri_;\r\n\r\n        emit BaseUriUpdated(_baseUri_);\r\n    }\r\n\r\n    /**\r\n     * @dev Mark for sale\r\n     * @notice Illuvitars cannot be used in game if they are open for sale\r\n     * @param tokenId tokenId\r\n     * @param _sale true or false\r\n     */\r\n    function markForSale(uint256 tokenId, bool _sale) external {\r\n        require(ownerOf(tokenId) == msg.sender, \"Not token owner\");\r\n        openForSale[tokenId] = _sale;\r\n    }\r\n\r\n    /// Return baseURI\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return __baseUri;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to withdraw from IMX\r\n     * @param to Recipient address\r\n     * @param quantity quantity - must be 1\r\n     * @param mintingBlob IMX minting blob string - {tokenId:blueprint}\r\n     */\r\n    function mintFor(\r\n        address to,\r\n        uint256 quantity,\r\n        bytes calldata mintingBlob\r\n    ) external override {\r\n        require(quantity == 1, \"Amount must be 1\");\r\n        require(msg.sender == imxMinter, \"caller is not minter\");\r\n        (uint256 id, bytes memory blueprint) = Minting.split(mintingBlob);\r\n        _mint(to, id, blueprint);\r\n    }\r\n\r\n    /// @dev Checks if the byte1 represented character is a decimal number or not (base 10)\r\n    function _isDecimal(bytes1 char) internal pure returns (bool) {\r\n        return uint8(char) >= 0x30 && uint8(char) < 0x3A;\r\n    }\r\n\r\n    /// @dev Mint interface with blueprint\r\n    function _mint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory blueprint\r\n    ) internal virtual;\r\n\r\n    /// @inheritdoc UUPSUpgradeable\r\n    function _authorizeUpgrade(address) internal virtual override onlyOwner {}\r\n\r\n    /// @dev UUPSUpgradeable storage gap\r\n    uint256[42] private __gap;\r\n}\r\n"
    },
    "contracts/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nenum AccessoryType {\r\n    Skin,\r\n    Body,\r\n    EyeWear,\r\n    HeadWear,\r\n    Props\r\n}\r\n\r\nenum BoxType {\r\n    Virtual,\r\n    Bronze,\r\n    Silver,\r\n    Gold,\r\n    Platinum,\r\n    Diamond\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721Enumerable_init_unchained();\n    }\n\n    function __ERC721Enumerable_init_unchained() internal initializer {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal initializer {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@imtbl/imx-contracts/contracts/IMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMintable {\n    function mintFor(\n        address to,\n        uint256 quantity,\n        bytes calldata mintingBlob\n    ) external;\n}\n"
    },
    "@imtbl/imx-contracts/contracts/utils/Minting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./Bytes.sol\";\n\nlibrary Minting {\n    // Split the minting blob into token_id and blueprint portions\n    // {token_id}:{blueprint}\n\n    function split(bytes calldata blob)\n        internal\n        pure\n        returns (uint256, bytes memory)\n    {\n        int256 index = Bytes.indexOf(blob, \":\", 0);\n        require(index >= 0, \"Separator must exist\");\n        // Trim the { and } from the parameters\n        uint256 tokenID = Bytes.toUint(blob[1:uint256(index) - 1]);\n        uint256 blueprintLength = blob.length - uint256(index) - 3;\n        if (blueprintLength == 0) {\n            return (tokenID, bytes(\"\"));\n        }\n        bytes calldata blueprint = blob[uint256(index) + 2:blob.length - 1];\n        return (tokenID, blueprint);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal initializer {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal initializer {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@imtbl/imx-contracts/contracts/utils/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary Bytes {\n    /**\n     * @dev Converts a `uint256` to a `string`.\n     * via OraclizeAPI - MIT licence\n     * https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n     */\n    function fromUint(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n\n    bytes constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(\n        bytes memory _base,\n        string memory _value,\n        uint256 _offset\n    ) internal pure returns (int256) {\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint256 i = _offset; i < _base.length; i++) {\n            if (_base[i] == _valueBytes[0]) {\n                return int256(i);\n            }\n        }\n\n        return -1;\n    }\n\n    function substring(\n        bytes memory strBytes,\n        uint256 startIndex,\n        uint256 endIndex\n    ) internal pure returns (string memory) {\n        bytes memory result = new bytes(endIndex - startIndex);\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function toUint(bytes memory b) internal pure returns (uint256) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 val = uint256(uint8(b[i]));\n            if (val >= 48 && val <= 57) {\n                // input is 0-9\n                result = result * 10 + (val - 48);\n            } else {\n                // invalid character, expecting integer input\n                revert(\"invalid input, only numbers allowed\");\n            }\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/protocol/Minter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\r\nimport \"../chainlink/VRFConsumerBaseUpgradeable.sol\";\r\nimport \"../DataTypes.sol\";\r\nimport \"../interfaces/PriceOracleSpec.sol\";\r\n\r\n/**\r\n * @title Minter\r\n * @notice Allow users to request minting Illuvitars.\r\n * @dev Users can use ETH or sILV to request minting.\r\n * @dev Minter uses an chainlink VRF to genrate randomness.\r\n * @author Dmitry Yakovlevich\r\n */\r\ncontract Minter is VRFConsumerBaseUpgradeable, UUPSUpgradeable, OwnableUpgradeable {\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\r\n    uint16 public constant MAX_TIER_CHANCE = 10000;\r\n    uint8 public constant TIER_COUNT = 6;\r\n\r\n    /// @dev Portrait mint information\r\n    mapping(BoxType => PortraitMintInfo) public portraitMintInfo;\r\n    /// @dev Accessory mint information\r\n    mapping(BoxType => AccessoryMintInfo) public accessoryMintInfo;\r\n    /// @dev User's mint requests\r\n    mapping(bytes32 => MintRequest) public mintRequests;\r\n    /// @dev Portrait sale window\r\n    SaleWindow public portraitSaleWindow;\r\n\r\n    /// @dev sILV2 token address\r\n    address public sIlv;\r\n    /// @dev treasury address\r\n    address public treasury;\r\n    /// @dev ILV/ETH Chainlink price feed address\r\n    IlluvitarsPriceOracle public illuvitarsPriceOracle;\r\n    /// @dev chainlink VRF key hash\r\n    bytes32 public vrfKeyHash;\r\n    /// @dev chainlink VRF fee\r\n    uint256 public vrfFee;\r\n\r\n    /* ======== EVENTS ======== */\r\n    /// @dev Emitted when treasury updated.\r\n    event TreasurySet(address indexed treasury);\r\n    /// @dev Emitted when user request mint.\r\n    event MintRequested(address indexed requester, bytes32 requestId);\r\n    /// @dev Emitted when chainlink fulfilled VRF request.\r\n    event RequestFulfilled(bytes32 indexed requestId, uint256 randomNumber);\r\n\r\n    /* ======== STRUCT ======== */\r\n    /// @dev Portrait mint params\r\n    struct PortraitMintParams {\r\n        BoxType boxType; // box type\r\n        uint64 amount; // portrait amount to mint\r\n    }\r\n\r\n    /// @dev Accessory semi random mint params\r\n    struct AccessorySemiRandomMintParams {\r\n        AccessoryType accessoryType; // accessory type\r\n        BoxType boxType; // box type\r\n        uint64 amount; // accessory amount to mint\r\n    }\r\n\r\n    /// @dev Accessory full random mint params\r\n    struct AccessoryFullRandomMintParams {\r\n        BoxType boxType; // box type\r\n        uint64 amount; // portrait amount to mint\r\n    }\r\n\r\n    /// @dev User's mint request data\r\n    struct MintRequest {\r\n        address requester; // requester address\r\n        PortraitMintParams[] portraitMintParams; // portrait mint params\r\n        AccessorySemiRandomMintParams[] accessorySemiRandomMintParams; // accessory semi mint params\r\n        AccessoryFullRandomMintParams[] accessoryFullRandomMintParams; // accessory full mint params\r\n        uint256 randomNumber; // random number from chainlink\r\n    }\r\n\r\n    /// @dev Mintable portrait info\r\n    struct PortraitInfo {\r\n        BoxType boxType; // box type\r\n        uint8 tier; // tier\r\n        uint256 rand; // extra random number to generate another off-chain data\r\n    }\r\n\r\n    /// @dev Mintable accessory info\r\n    struct AccessoryInfo {\r\n        BoxType boxType; // box type\r\n        AccessoryType accessoryType; // accessory type\r\n        uint8 tier; // tier\r\n    }\r\n\r\n    /// @dev Portrait price and tier pick chances for each box type\r\n    struct PortraitMintInfo {\r\n        uint256 price; // price\r\n        uint16[6] tierChances; // tier chances\r\n    }\r\n\r\n    /// @dev Accessory semi and random price and tier pick chances for each box type\r\n    struct AccessoryMintInfo {\r\n        uint256 randomPrice; // full random price\r\n        uint256 semiRandomPrice; // semi random price\r\n        uint16[6] tierChances; // tier chances\r\n    }\r\n\r\n    /// @dev Sale window\r\n    struct SaleWindow {\r\n        uint64 start;\r\n        uint64 end;\r\n    }\r\n\r\n    /**\r\n     * @dev UUPSUpgradeable initializer\r\n     * @param _vrfCoordinator Chainlink VRF Coordinator address\r\n     * @param _linkToken LINK token address\r\n     * @param _vrfKeyhash Chainlink VRF Key Hash\r\n     * @param _vrfFee Chainlink VRF Fee\r\n     * @param _treasury Treasury address\r\n     * @param _sIlv sILV2 token address\r\n     * @param _illuvitarsPriceOracle ILV/ETH Chainlink price feed base illuvitars price oracle\r\n     */\r\n    function initialize(\r\n        address _vrfCoordinator,\r\n        address _linkToken,\r\n        bytes32 _vrfKeyhash,\r\n        uint256 _vrfFee,\r\n        address _treasury,\r\n        address _sIlv,\r\n        address _illuvitarsPriceOracle\r\n    ) external initializer {\r\n        require(\r\n            _treasury != address(0) && _illuvitarsPriceOracle != address(0) && _sIlv != address(0),\r\n            \"cannot zero address\"\r\n        );\r\n\r\n        __Ownable_init();\r\n        __VRFConsumerBase_init(_vrfCoordinator, _linkToken);\r\n\r\n        vrfKeyHash = _vrfKeyhash;\r\n        vrfFee = _vrfFee;\r\n        sIlv = _sIlv;\r\n        treasury = _treasury;\r\n        illuvitarsPriceOracle = IlluvitarsPriceOracle(_illuvitarsPriceOracle);\r\n\r\n        _initializePortraitMintInfo();\r\n        _initializeAccessoryMintInfo();\r\n    }\r\n\r\n    /**\r\n     * @dev Set portrait sale window.\r\n     * @dev only owner can call this function.\r\n     * @param _saleWindow New sale window.\r\n     */\r\n    function setPortraitSaleWindow(SaleWindow calldata _saleWindow) external onlyOwner {\r\n        require(_saleWindow.start < _saleWindow.end, \"Invalid sale window\");\r\n        portraitSaleWindow = _saleWindow;\r\n    }\r\n\r\n    /**\r\n     * @dev Set new treasury address.\r\n     * @dev only owner can call this function.\r\n     * @param treasury_ Treasury Address.\r\n     */\r\n    function setTreasury(address treasury_) external onlyOwner {\r\n        require(treasury_ != address(0), \"Treasury address cannot zero\");\r\n        treasury = treasury_;\r\n\r\n        emit TreasurySet(treasury_);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint for random accessory, callback for VRFConsumerBase\r\n     * @dev inaccessible from outside\r\n     * @param requestId requested random accesory Id.\r\n     * @param randomNumber Random Number.\r\n     */\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomNumber) internal override {\r\n        require(mintRequests[requestId].requester != address(0), \"No request exist\");\r\n        require(mintRequests[requestId].randomNumber == 0, \"Random number already fulfilled\");\r\n\r\n        mintRequests[requestId].randomNumber = randomNumber;\r\n\r\n        emit RequestFulfilled(requestId, randomNumber);\r\n    }\r\n\r\n    /**\r\n     * @dev Request minting Portrait and Accesory NFTs.\r\n     * @notice Users pay ETH or sILV to request minting\r\n     * @param portraitMintParams portrait layer mint params.\r\n     * @param accessorySemiRandomMintParams accessory layer semi random mint params.\r\n     * @param accessoryFullRandomMintParams accessory layer full random mint params.\r\n     * @param useSIlv true to use sILV, false to use ETH.\r\n     */\r\n    function purchase(\r\n        PortraitMintParams[] calldata portraitMintParams,\r\n        AccessorySemiRandomMintParams[] calldata accessorySemiRandomMintParams,\r\n        AccessoryFullRandomMintParams[] calldata accessoryFullRandomMintParams,\r\n        bool useSIlv\r\n    ) external payable {\r\n        uint256 etherPrice;\r\n\r\n        bytes32 requestId = requestRandomness(vrfKeyHash, vrfFee);\r\n\r\n        MintRequest storage mintRequest = mintRequests[requestId];\r\n        require(mintRequest.requester == address(0), \"Already requested\");\r\n        mintRequest.requester = msg.sender;\r\n\r\n        uint256 length = portraitMintParams.length;\r\n        if (length > 0) {\r\n            require(\r\n                block.timestamp >= portraitSaleWindow.start && block.timestamp >= portraitSaleWindow.end,\r\n                \"Sale not started or ended\"\r\n            );\r\n        }\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            PortraitMintParams memory param = portraitMintParams[i];\r\n            require(param.amount > 0, \"Invalid amount\");\r\n            etherPrice += uint256(param.amount) * portraitMintInfo[param.boxType].price;\r\n            mintRequest.portraitMintParams.push(param);\r\n        }\r\n\r\n        length = accessorySemiRandomMintParams.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            AccessorySemiRandomMintParams memory param = accessorySemiRandomMintParams[i];\r\n            require(param.amount > 0, \"Invalid amount\");\r\n            etherPrice += uint256(param.amount) * accessoryMintInfo[param.boxType].semiRandomPrice;\r\n            mintRequest.accessorySemiRandomMintParams.push(param);\r\n        }\r\n\r\n        length = accessoryFullRandomMintParams.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            AccessoryFullRandomMintParams memory param = accessoryFullRandomMintParams[i];\r\n            etherPrice += uint256(param.amount) * accessoryMintInfo[param.boxType].randomPrice;\r\n            mintRequest.accessoryFullRandomMintParams.push(param);\r\n        }\r\n\r\n        if (etherPrice != 0) {\r\n            if (useSIlv) {\r\n                uint256 tokenAmount = uint256(illuvitarsPriceOracle.ethToIlv(etherPrice));\r\n                IERC20Upgradeable(sIlv).safeTransferFrom(msg.sender, treasury, tokenAmount);\r\n            } else {\r\n                require(msg.value == etherPrice, \"Invalid price\");\r\n                payable(treasury).transfer(etherPrice);\r\n            }\r\n        }\r\n\r\n        emit MintRequested(msg.sender, requestId);\r\n    }\r\n\r\n    /**\r\n     * @dev Get mintable portrait and accessory infos with chainlink random number\r\n     * @param requestId Request id of mint request.\r\n     * @return requester Requester address\r\n     * @return seed Seed random number from chainlink\r\n     * @return portraits Mintable portrait on-chain metadata\r\n     * @return accessories Mintable accessory on-chain metadata\r\n     */\r\n    function getMintResult(bytes32 requestId)\r\n        external\r\n        view\r\n        returns (\r\n            address requester,\r\n            uint256 seed,\r\n            PortraitInfo[] memory portraits,\r\n            AccessoryInfo[] memory accessories\r\n        )\r\n    {\r\n        require(mintRequests[requestId].randomNumber != 0, \"No random number generated\");\r\n        MintRequest memory mintRequest = mintRequests[requestId];\r\n        requester = mintRequest.requester;\r\n        seed = mintRequest.randomNumber;\r\n\r\n        uint256 rand = seed;\r\n        if (mintRequest.portraitMintParams.length > 0) {\r\n            (portraits, rand) = _getPortraitsInfo(rand, mintRequest.portraitMintParams);\r\n        }\r\n\r\n        if (\r\n            mintRequest.accessoryFullRandomMintParams.length > 0 || mintRequest.accessorySemiRandomMintParams.length > 0\r\n        ) {\r\n            accessories = _getAccessoriesInfo(\r\n                rand,\r\n                mintRequest.accessoryFullRandomMintParams,\r\n                mintRequest.accessorySemiRandomMintParams\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to get mintable portrait infos\r\n     * @param seed Seed random number to generate portrait infos\r\n     * @param portraitMintParams Users portrait mint params\r\n     * @return portraits Mintable portrait on-chain metadata\r\n     * @return lastRand Last random number to generate accessory metadata\r\n     */\r\n    function _getPortraitsInfo(uint256 seed, PortraitMintParams[] memory portraitMintParams)\r\n        internal\r\n        view\r\n        returns (PortraitInfo[] memory portraits, uint256 lastRand)\r\n    {\r\n        uint256 portraitAmount;\r\n\r\n        uint256 length = portraitMintParams.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            portraitAmount += portraitMintParams[i].amount;\r\n        }\r\n\r\n        uint256 rand = seed;\r\n        if (portraitAmount > 0) {\r\n            portraits = new PortraitInfo[](portraitAmount);\r\n\r\n            for (uint256 i = 0; i < length; i += 1) {\r\n                uint256 amount = portraitMintParams[i].amount;\r\n                for (uint256 j = 0; j < amount; j += 1) {\r\n                    rand = uint256(keccak256(abi.encode(rand, rand)));\r\n                    uint16 chance = uint16(rand % MAX_TIER_CHANCE);\r\n                    uint16[6] memory tierChances = portraitMintInfo[portraitMintParams[i].boxType].tierChances;\r\n                    for (uint8 k = 0; k < TIER_COUNT; k += 1) {\r\n                        if (tierChances[k] > chance) {\r\n                            portraits[i] = PortraitInfo({\r\n                                boxType: portraitMintParams[i].boxType,\r\n                                tier: k,\r\n                                rand: rand / MAX_TIER_CHANCE\r\n                            });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        lastRand = rand;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal method to get mintable accessories infos\r\n     * @param seed Seed random number to generate portrait infos\r\n     * @param fullRandomMintParams Users accessory full mint params\r\n     * @param semiRandomMintParams Users accessory semi mint params\r\n     * @return accessories Mintable accessory on-chain metadata\r\n     */\r\n    function _getAccessoriesInfo(\r\n        uint256 seed,\r\n        AccessoryFullRandomMintParams[] memory fullRandomMintParams,\r\n        AccessorySemiRandomMintParams[] memory semiRandomMintParams\r\n    ) internal view returns (AccessoryInfo[] memory accessories) {\r\n        uint256 fullRandomAmount;\r\n        uint256 semiRandomAmount;\r\n        uint256 length = fullRandomMintParams.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            fullRandomAmount += fullRandomMintParams[i].amount;\r\n        }\r\n\r\n        length = semiRandomMintParams.length;\r\n        for (uint256 i = 0; i < length; i += 1) {\r\n            semiRandomAmount += semiRandomMintParams[i].amount;\r\n        }\r\n\r\n        uint256 rand = seed;\r\n        if (semiRandomAmount > 0 || fullRandomAmount > 0) {\r\n            accessories = new AccessoryInfo[](semiRandomAmount + fullRandomAmount);\r\n\r\n            for (uint256 i = 0; i < length; i += 1) {\r\n                uint256 amount = semiRandomMintParams[i].amount;\r\n                for (uint256 j = 0; j < amount; j += 1) {\r\n                    rand = uint256(keccak256(abi.encode(rand, rand)));\r\n                    uint16 chance = uint16(rand % MAX_TIER_CHANCE);\r\n                    uint16[6] memory tierChances = accessoryMintInfo[semiRandomMintParams[i].boxType].tierChances;\r\n                    for (uint8 k = 0; k < TIER_COUNT; k += 1) {\r\n                        if (tierChances[k] > chance) {\r\n                            accessories[i] = AccessoryInfo({\r\n                                boxType: semiRandomMintParams[i].boxType,\r\n                                accessoryType: semiRandomMintParams[i].accessoryType,\r\n                                tier: k\r\n                            });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            length = fullRandomMintParams.length;\r\n            for (uint256 i = 0; i < length; i += 1) {\r\n                uint256 amount = fullRandomMintParams[i].amount;\r\n                for (uint256 j = 0; j < amount; j += 1) {\r\n                    rand = uint256(keccak256(abi.encode(rand, rand)));\r\n                    uint16 chance = uint16(rand % MAX_TIER_CHANCE);\r\n                    AccessoryType accessoryType = AccessoryType(uint8((rand / MAX_TIER_CHANCE) % 5));\r\n                    uint16[6] memory tierChances = accessoryMintInfo[fullRandomMintParams[i].boxType].tierChances;\r\n                    for (uint8 k = 0; k < TIER_COUNT; k += 1) {\r\n                        if (tierChances[k] > chance) {\r\n                            accessories[i + semiRandomAmount] = AccessoryInfo({\r\n                                boxType: fullRandomMintParams[i].boxType,\r\n                                accessoryType: accessoryType,\r\n                                tier: k\r\n                            });\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Delete fulfilled mint requests\r\n     * @param requestId Request id\r\n     */\r\n    function deleteFulfilledMintRequest(bytes32 requestId) external onlyOwner {\r\n        require(mintRequests[requestId].requester != address(0), \"Request does not exist!\");\r\n        require(mintRequests[requestId].randomNumber != 0, \"Random number not generated\");\r\n        delete mintRequests[requestId];\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize portrait mint information\r\n     * @notice Price and tier chances are constant\r\n     */\r\n    function _initializePortraitMintInfo() internal {\r\n        portraitMintInfo[BoxType.Virtual] = PortraitMintInfo({ price: 0, tierChances: [10000, 0, 0, 0, 0, 0] });\r\n        portraitMintInfo[BoxType.Bronze] = PortraitMintInfo({\r\n            price: 5e16,\r\n            tierChances: [0, 8000, 9700, 9930, 9980, 10000]\r\n        });\r\n        portraitMintInfo[BoxType.Silver] = PortraitMintInfo({\r\n            price: 10e16,\r\n            tierChances: [0, 6100, 8800, 9700, 9950, 10000]\r\n        });\r\n        portraitMintInfo[BoxType.Gold] = PortraitMintInfo({\r\n            price: 25e16,\r\n            tierChances: [0, 2400, 6600, 8800, 9700, 10000]\r\n        });\r\n        portraitMintInfo[BoxType.Platinum] = PortraitMintInfo({\r\n            price: 75e16,\r\n            tierChances: [0, 500, 2000, 4250, 8250, 10000]\r\n        });\r\n        portraitMintInfo[BoxType.Diamond] = PortraitMintInfo({\r\n            price: 250e16,\r\n            tierChances: [0, 200, 1000, 2500, 5000, 10000]\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize accessory mint information\r\n     * @notice Price and tier chances are constant\r\n     */\r\n    function _initializeAccessoryMintInfo() internal {\r\n        accessoryMintInfo[BoxType.Virtual] = AccessoryMintInfo({\r\n            randomPrice: 0,\r\n            semiRandomPrice: 0,\r\n            tierChances: [10000, 0, 0, 0, 0, 0]\r\n        });\r\n        accessoryMintInfo[BoxType.Bronze] = AccessoryMintInfo({\r\n            randomPrice: 5e16,\r\n            semiRandomPrice: 10e16,\r\n            tierChances: [0, 8100, 9200, 9700, 9900, 10000]\r\n        });\r\n        accessoryMintInfo[BoxType.Silver] = AccessoryMintInfo({\r\n            randomPrice: 10e16,\r\n            semiRandomPrice: 20e16,\r\n            tierChances: [0, 3000, 7600, 8800, 9700, 10000]\r\n        });\r\n        accessoryMintInfo[BoxType.Gold] = AccessoryMintInfo({\r\n            randomPrice: 15e16,\r\n            semiRandomPrice: 30e16,\r\n            tierChances: [0, 1500, 4700, 7200, 9000, 10000]\r\n        });\r\n        accessoryMintInfo[BoxType.Platinum] = AccessoryMintInfo({\r\n            randomPrice: 20e16,\r\n            semiRandomPrice: 40e16,\r\n            tierChances: [0, 500, 2000, 5300, 8000, 10000]\r\n        });\r\n        accessoryMintInfo[BoxType.Diamond] = AccessoryMintInfo({\r\n            randomPrice: 25e16,\r\n            semiRandomPrice: 50e16,\r\n            tierChances: [0, 100, 600, 2800, 6000, 10000]\r\n        });\r\n    }\r\n\r\n    /// @inheritdoc UUPSUpgradeable\r\n    function _authorizeUpgrade(address) internal virtual override onlyOwner {}\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/chainlink/VRFConsumerBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\n/**\r\n * @title VRFConsumerBaseUpgradeable\r\n * @dev Has same functionality as Chainlink VRFConsumerBase.sol, but used for upgradeable\r\n */\r\nabstract contract VRFConsumerBaseUpgradeable is Initializable, VRFRequestIDBase {\r\n    /**\r\n     * @notice fulfillRandomness handles the VRF response. Your contract must\r\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n     * @notice principles to keep in mind when implementing your fulfillRandomness\r\n     * @notice method.\r\n     *\r\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\r\n     * @dev signature, and will call it once it has verified the proof\r\n     * @dev associated with the randomness. (It is triggered via a call to\r\n     * @dev rawFulfillRandomness, below.)\r\n     *\r\n     * @param requestId The Id initially returned by requestRandomness\r\n     * @param randomness the VRF output\r\n     */\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\r\n\r\n    /**\r\n     * @dev In order to keep backwards compatibility we have kept the user\r\n     * seed field around. We remove the use of it because given that the blockhash\r\n     * enters later, it overrides whatever randomness the used seed provides.\r\n     * Given that it adds no security, and can easily lead to misunderstandings,\r\n     * we have removed it from usage and can now provide a simpler API.\r\n     */\r\n    uint256 private constant USER_SEED_PLACEHOLDER = 0;\r\n\r\n    /**\r\n     * @notice requestRandomness initiates a request for VRF output given _seed\r\n     *\r\n     * @dev The fulfillRandomness method receives the output, once it's provided\r\n     * @dev by the Oracle, and verified by the vrfCoordinator.\r\n     *\r\n     * @dev The _keyHash must already be registered with the VRFCoordinator, and\r\n     * @dev the _fee must exceed the fee specified during registration of the\r\n     * @dev _keyHash.\r\n     *\r\n     * @dev The _seed parameter is vestigial, and is kept only for API\r\n     * @dev compatibility with older versions. It can't *hurt* to mix in some of\r\n     * @dev your own randomness, here, but it's not necessary because the VRF\r\n     * @dev oracle will mix the hash of the block containing your request into the\r\n     * @dev VRF seed it ultimately uses.\r\n     *\r\n     * @param _keyHash ID of public key against which randomness is generated\r\n     * @param _fee The amount of LINK to send with the request\r\n     *\r\n     * @return requestId unique ID for this request\r\n     *\r\n     * @dev The returned requestId can be used to distinguish responses to\r\n     * @dev concurrent requests. It is passed as the first argument to\r\n     * @dev fulfillRandomness.\r\n     */\r\n    function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\r\n        LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\r\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\r\n        // the hash of the block containing this request to obtain the seed/input\r\n        // which is finally passed to the VRF cryptographic machinery.\r\n        uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\r\n        // nonces[_keyHash] must stay in sync with\r\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n        // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\r\n        // This provides protection against the user repeating their input seed,\r\n        // which would result in a predictable/duplicate output, if multiple such\r\n        // requests appeared in the same block.\r\n        nonces[_keyHash] = nonces[_keyHash] + 1;\r\n        return makeRequestId(_keyHash, vRFSeed);\r\n    }\r\n\r\n    LinkTokenInterface internal LINK;\r\n    address private vrfCoordinator;\r\n\r\n    // Nonces for each VRF key from which randomness has been requested.\r\n    //\r\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\r\n    mapping(bytes32 => uint256) /* keyHash */ /* nonce */\r\n        private nonces;\r\n\r\n    /**\r\n     * @param _vrfCoordinator address of VRFCoordinator contract\r\n     * @param _link address of LINK token contract\r\n     *\r\n     * @dev https://docs.chain.link/docs/link-token-contracts\r\n     */\r\n    function __VRFConsumerBase_init(address _vrfCoordinator, address _link) internal initializer {\r\n        vrfCoordinator = _vrfCoordinator;\r\n        LINK = LinkTokenInterface(_link);\r\n    }\r\n\r\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n    // the origin of the call\r\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n        require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n        fulfillRandomness(requestId, randomness);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/PriceOracleSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title Pair Price Oracle, a.k.a. Pair Oracle\r\n *\r\n * @notice Generic interface used to consult on the Uniswap-like token pairs conversion prices;\r\n *      one pair oracle is used to consult on the exchange rate within a single token pair\r\n *\r\n * @notice See also: https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/building-an-oracle\r\n *\r\n * @author Basil Gorin\r\n */\r\ninterface PairOracle {\r\n    /**\r\n     * @notice Updates the oracle with the price values if required, for example\r\n     *      the cumulative price at the start and end of a period, etc.\r\n     *\r\n     * @dev This function is part of the oracle maintenance flow\r\n     */\r\n    function update() external;\r\n\r\n    /**\r\n     * @notice For a pair of tokens A/B (sell/buy), consults on the amount of token B to be\r\n     *      bought if the specified amount of token A to be sold\r\n     *\r\n     * @dev This function is part of the oracle usage flow\r\n     *\r\n     * @param token token A (token to sell) address\r\n     * @param amountIn amount of token A to sell\r\n     * @return amountOut amount of token B to be bought\r\n     */\r\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\r\n}\r\n\r\n/**\r\n * @title Price Oracle Registry\r\n *\r\n * @notice To make pair oracles more convenient to use, a more generic Oracle Registry\r\n *        interface is introduced: it stores the addresses of pair price oracles and allows\r\n *        searching/querying for them\r\n *\r\n * @author Basil Gorin\r\n */\r\ninterface PriceOracleRegistry {\r\n    /**\r\n     * @notice Searches for the Pair Price Oracle for A/B (sell/buy) token pair\r\n     *\r\n     * @param tokenA token A (token to sell) address\r\n     * @param tokenB token B (token to buy) address\r\n     * @return pairOracle pair price oracle address for A/B token pair\r\n     */\r\n    function getPriceOracle(address tokenA, address tokenB) external view returns (address pairOracle);\r\n}\r\n\r\n/**\r\n * @title Illuvitars Price Oracle\r\n *\r\n * @notice Supports the Illuvitars with the ETH/ILV conversion required,\r\n *       marker interface is required to support ERC165 lookups\r\n *\r\n * @author Basil Gorin\r\n */\r\ninterface IlluvitarsPriceOracle {\r\n    /**\r\n     * @notice Powers the ETH/ILV illuvitar token price conversion, used when\r\n     *      selling the illuvitar for sILV to determine how much sILV to accept\r\n     *      instead of the nominated ETH price\r\n     *\r\n     * @notice Note that sILV price is considered to be equal to ILV price\r\n     *\r\n     * @dev Implementation must guarantee not to return zero, absurdly small\r\n     *      or big values, it must guarantee the price is up to date with some\r\n     *      reasonable update interval threshold\r\n     *\r\n     * @param ethOut amount of ETH sale contract is expecting to get\r\n     * @return ilvIn amount of sILV sale contract should accept instead\r\n     */\r\n    function ethToIlv(uint256 ethOut) external returns (uint256 ilvIn);\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "contracts/protocol/IlluvitarsPriceOracleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../interfaces/ERC165Spec.sol\";\r\nimport \"../interfaces/PriceOracleSpec.sol\";\r\nimport \"../utils/UpgradeableAccessControl.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n/**\r\n * @title Chainlink Price Feed Aggregator based Illuvitars Price Oracle\r\n *\r\n * @notice IlluvitarsPriceOracle implementation based on ILV/ETH Chainlink price feeds,\r\n *      see https://docs.chain.link/docs/ethereum-addresses/\r\n *      see https://docs.chain.link/docs/using-chainlink-reference-contracts/\r\n *\r\n * @author Basil Gorin\r\n */\r\ncontract IlluvitarsPriceOracleV1 is ERC165, IlluvitarsPriceOracle, UpgradeableAccessControl {\r\n    /**\r\n     * @notice Chainlink ILV/ETH price feed aggregator maintains ILV/ETH price feed\r\n     */\r\n    AggregatorV3Interface public aggregator;\r\n\r\n    /**\r\n     * @notice When communicating with Chainlink ILV/ETH price feed, we verify how old\r\n     *      the IV/ETH price is, and if it is older than `oldAnswerThreshold`, the answer\r\n     *      is treated as old and is not used: `ethToIlv` conversion function throws in this case\r\n     */\r\n    uint256 public oldAnswerThreshold;\r\n\r\n    /**\r\n     * @notice Price Oracle manager is responsible for updating `oldAnswerThreshold` value,\r\n     *      and other price oracle configuration values in the future\r\n     *\r\n     * @dev Role ROLE_PRICE_ORACLE_MANAGER allows updating the `oldAnswerThreshold` value\r\n     *      (executing `setOldAnswerThreshold` function)\r\n     */\r\n    uint32 public constant ROLE_PRICE_ORACLE_MANAGER = 0x0001_0000;\r\n\r\n    /**\r\n     * @dev Fired in setOldAnswerThreshold()\r\n     *\r\n     * @param _by an address which executed update\r\n     * @param _oldVal old oldAnswerThreshold value\r\n     * @param _newVal new oldAnswerThreshold value\r\n     */\r\n    event OldAnswerThresholdUpdated(address indexed _by, uint256 _oldVal, uint256 _newVal);\r\n\r\n    /**\r\n     * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\r\n     *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\r\n     *\r\n     * @param _aggregator Chainlink ILV/ETH price feed aggregator address\r\n     */\r\n    function initialize(address _aggregator) public virtual initializer {\r\n        // verify the inputs are set\r\n        require(_aggregator != address(0), \"aggregator address is not set\");\r\n\r\n        // assign the addresses\r\n        aggregator = AggregatorV3Interface(_aggregator);\r\n\r\n        // set the default value for the threshold\r\n        oldAnswerThreshold = 30 hours;\r\n\r\n        // verify the inputs are valid smart contracts of the expected interfaces\r\n        // since Chainlink AggregatorV3Interface doesn't support ERC165, verify\r\n        // by executing the functions we're going to use anyway\r\n        // get the data\r\n        uint8 decimals = aggregator.decimals();\r\n        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = aggregator\r\n            .latestRoundData();\r\n        // verify the response\r\n        require(\r\n            decimals > 0 && roundId > 0 && answer > 0 && startedAt > 0 && updatedAt > 0 && answeredInRound > 0,\r\n            \"unexpected aggregator response\"\r\n        );\r\n\r\n        // execute all parent initializers in cascade\r\n        UpgradeableAccessControl._postConstruct(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Restricted access function to update `oldAnswerThreshold` value, used\r\n     *       in `ethToIlv` conversion function to determine if Chainlink ILV/ETH price feed\r\n     *       returns the value fresh enough to be used\r\n     *\r\n     * @notice Note: `ethToIlv` conversion function throws if Chainlink ILV/ETH price feed\r\n     *      answer is older then `oldAnswerThreshold` value\r\n     *\r\n     * @notice Chainlink is expected to update ILV/ETH price at least one per day (24 hours)\r\n     *      therefore `oldAnswerThreshold` should be kept bigger than 24 hours\r\n     *\r\n     * @param _oldAnswerThreshold `oldAnswerThreshold` value to set\r\n     */\r\n    function setOldAnswerThreshold(uint256 _oldAnswerThreshold) public {\r\n        // verify the access permission\r\n        require(isSenderInRole(ROLE_PRICE_ORACLE_MANAGER), \"access denied\");\r\n\r\n        // check that the value supplied resides in a reasonable bounds\r\n        require(_oldAnswerThreshold > 1 hours, \"threshold too low\");\r\n        require(_oldAnswerThreshold < 7 days, \"threshold too high\");\r\n\r\n        // emit an event first - to log both old and new values\r\n        emit OldAnswerThresholdUpdated(msg.sender, oldAnswerThreshold, _oldAnswerThreshold);\r\n\r\n        // update the `oldAnswerThreshold` value\r\n        oldAnswerThreshold = _oldAnswerThreshold;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc ERC165\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\r\n        // determine and return the interface support\r\n        return interfaceID == type(IlluvitarsPriceOracle).interfaceId;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc IlluvitarsPriceOracle\r\n     */\r\n    function ethToIlv(uint256 ethOut) public view virtual override returns (uint256 ilvIn) {\r\n        // get the latest round data from Chainlink price feed aggregator\r\n        // see https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata\r\n        (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = aggregator\r\n            .latestRoundData();\r\n\r\n        // verify if the data obtained from Chainlink looks fresh, updated recently\r\n        // TODO: review and check with Chainlink this is a correct way of ensuring data freshness\r\n        require(roundId == answeredInRound && startedAt <= updatedAt && updatedAt <= now256(), \"invalid answer\");\r\n        require(updatedAt > now256() - oldAnswerThreshold, \"answer is too old\");\r\n\r\n        // calculate according to `ethOut * ilvIn / ethOut` formula and return\r\n        return (ethOut * 10**aggregator.decimals()) / uint256(answer);\r\n    }\r\n\r\n    /**\r\n     * @dev Testing time-dependent functionality may be difficult;\r\n     *      we override time in the helper test smart contract (mock)\r\n     *\r\n     * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\r\n     */\r\n    function now256() public view virtual returns (uint256) {\r\n        // return current block timestamp\r\n        return block.timestamp;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title ERC-165 Standard Interface Detection\r\n *\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * @dev Implementers can declare support of contract interfaces,\r\n *      which can then be queried by others.\r\n *\r\n * @author Christian Reitwiener, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\r\n */\r\ninterface ERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     *\r\n     * @dev Interface identification is specified in ERC-165.\r\n     *      This function uses less than 30,000 gas.\r\n     *\r\n     * @param interfaceID The interface identifier, as specified in ERC-165\r\n     * @return `true` if the contract implements `interfaceID` and\r\n     *      `interfaceID` is not 0xffffffff, `false` otherwise\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\n/**\r\n * @title Upgradeable Access Control List // ERC1967Proxy\r\n *\r\n * @notice Access control smart contract provides an API to check\r\n *      if a specific operation is permitted globally and/or\r\n *      if a particular user has a permission to execute it.\r\n *\r\n * @notice It deals with two main entities: features and roles.\r\n *\r\n * @notice Features are designed to be used to enable/disable public functions\r\n *      of the smart contract (used by a wide audience).\r\n * @notice User roles are designed to control the access to restricted functions\r\n *      of the smart contract (used by a limited set of maintainers).\r\n *\r\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\r\n *      in the documentation text and may be used interchangeably.\r\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\r\n *\r\n * @notice Access manager is a special role which allows to grant/revoke other roles.\r\n *      Access managers can only grant/revoke permissions which they have themselves.\r\n *      As an example, access manager with no other roles set can only grant/revoke its own\r\n *      access manager permission and nothing else.\r\n *\r\n * @notice Access manager permission should be treated carefully, as a super admin permission:\r\n *      Access manager with even no other permission can interfere with another account by\r\n *      granting own access manager permission to it and effectively creating more powerful\r\n *      permission set than its own.\r\n *\r\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\r\n *      to check/know \"who is allowed to do this thing\".\r\n * @dev Zeppelin implementation is more flexible:\r\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\r\n *      - it allows setting an admin for each role, while current allows having only one global admin\r\n * @dev Current implementation is more lightweight:\r\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\r\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\r\n *        setting only one role in a single transaction\r\n *\r\n * @dev This smart contract is designed to be inherited by other\r\n *      smart contracts which require access control management capabilities.\r\n *\r\n * @dev Access manager permission has a bit 255 set.\r\n *      This bit must not be used by inheriting contracts for any other permissions/features.\r\n *\r\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\r\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\r\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\r\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\r\n *\r\n * @author Basil Gorin\r\n */\r\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\r\n    /**\r\n     * @notice Privileged addresses with defined roles/permissions\r\n     * @notice In the context of ERC20/ERC721 tokens these can be permissions to\r\n     *      allow minting or burning tokens, transferring on behalf and so on\r\n     *\r\n     * @dev Maps user address to the permissions bitmask (role), where each bit\r\n     *      represents a permission\r\n     * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n     *      represents all possible permissions\r\n     * @dev 'This' address mapping represents global features of the smart contract\r\n     */\r\n    mapping(address => uint256) public userRoles;\r\n\r\n    /**\r\n     * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\r\n     *      the amount of storage used by a contract always adds up to the 50.\r\n     *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n\r\n    /**\r\n     * @notice Access manager is responsible for assigning the roles to users,\r\n     *      enabling/disabling global features of the smart contract\r\n     * @notice Access manager can add, remove and update user roles,\r\n     *      remove and update global features\r\n     *\r\n     * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\r\n     * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\r\n     */\r\n    uint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @notice Upgrade manager is responsible for smart contract upgrades,\r\n     *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\r\n     *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\r\n     *\r\n     * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\r\n     * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\r\n     */\r\n    uint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @dev Bitmask representing all the possible permissions (super admin role)\r\n     * @dev Has all the bits are enabled (2^256 - 1 value)\r\n     */\r\n    uint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\r\n\r\n    /**\r\n     * @dev Fired in updateRole() and updateFeatures()\r\n     *\r\n     * @param _by operator which called the function\r\n     * @param _to address which was granted/revoked permissions\r\n     * @param _requested permissions requested\r\n     * @param _actual permissions effectively set\r\n     */\r\n    event RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\r\n\r\n    /**\r\n     * @dev UUPS initializer, sets the contract owner to have full privileges\r\n     *\r\n     * @param _owner smart contract owner having full privileges\r\n     */\r\n    function _postConstruct(address _owner) internal virtual initializer {\r\n        // grant owner full privileges\r\n        userRoles[_owner] = FULL_PRIVILEGES_MASK;\r\n\r\n        // fire an event\r\n        emit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an address of the implementation smart contract,\r\n     *      see ERC1967Upgrade._getImplementation()\r\n     *\r\n     * @return the current implementation address\r\n     */\r\n    function getImplementation() public view virtual returns (address) {\r\n        // delegate to `ERC1967Upgrade._getImplementation()`\r\n        return _getImplementation();\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves globally set of features enabled\r\n     *\r\n     * @dev Effectively reads userRoles role for the contract itself\r\n     *\r\n     * @return 256-bit bitmask of the features enabled\r\n     */\r\n    function features() public view returns (uint256) {\r\n        // features are stored in 'this' address  mapping of `userRoles` structure\r\n        return userRoles[address(this)];\r\n    }\r\n\r\n    /**\r\n     * @notice Updates set of the globally enabled features (`features`),\r\n     *      taking into account sender's permissions\r\n     *\r\n     * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\r\n     * @dev Function is left for backward compatibility with older versions\r\n     *\r\n     * @param _mask bitmask representing a set of features to enable/disable\r\n     */\r\n    function updateFeatures(uint256 _mask) public {\r\n        // delegate call to `updateRole`\r\n        updateRole(address(this), _mask);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates set of permissions (role) for a given user,\r\n     *      taking into account sender's permissions.\r\n     *\r\n     * @dev Setting role to zero is equivalent to removing an all permissions\r\n     * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\r\n     *      copying senders' permissions (role) to the user\r\n     * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\r\n     *\r\n     * @param operator address of a user to alter permissions for or zero\r\n     *      to alter global features of the smart contract\r\n     * @param role bitmask representing a set of permissions to\r\n     *      enable/disable for a user specified\r\n     */\r\n    function updateRole(address operator, uint256 role) public {\r\n        // caller must have a permission to update user roles\r\n        require(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\r\n\r\n        // evaluate the role and reassign it\r\n        userRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\r\n\r\n        // fire an event\r\n        emit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\r\n    }\r\n\r\n    /**\r\n     * @notice Determines the permission bitmask an operator can set on the\r\n     *      target permission set\r\n     * @notice Used to calculate the permission bitmask to be set when requested\r\n     *     in `updateRole` and `updateFeatures` functions\r\n     *\r\n     * @dev Calculated based on:\r\n     *      1) operator's own permission set read from userRoles[operator]\r\n     *      2) target permission set - what is already set on the target\r\n     *      3) desired permission set - what do we want set target to\r\n     *\r\n     * @dev Corner cases:\r\n     *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\r\n     *        `desired` bitset is returned regardless of the `target` permission set value\r\n     *        (what operator sets is what they get)\r\n     *      2) Operator with no permissions (zero bitset):\r\n     *        `target` bitset is returned regardless of the `desired` value\r\n     *        (operator has no authority and cannot modify anything)\r\n     *\r\n     * @dev Example:\r\n     *      Consider an operator with the permissions bitmask     00001111\r\n     *      is about to modify the target permission set          01010101\r\n     *      Operator wants to set that permission set to          00110011\r\n     *      Based on their role, an operator has the permissions\r\n     *      to update only lowest 4 bits on the target, meaning that\r\n     *      high 4 bits of the target set in this example is left\r\n     *      unchanged and low 4 bits get changed as desired:      01010011\r\n     *\r\n     * @param operator address of the contract operator which is about to set the permissions\r\n     * @param target input set of permissions to operator is going to modify\r\n     * @param desired desired set of permissions operator would like to set\r\n     * @return resulting set of permissions given operator will set\r\n     */\r\n    function evaluateBy(\r\n        address operator,\r\n        uint256 target,\r\n        uint256 desired\r\n    ) public view returns (uint256) {\r\n        // read operator's permissions\r\n        uint256 p = userRoles[operator];\r\n\r\n        // taking into account operator's permissions,\r\n        // 1) enable the permissions desired on the `target`\r\n        target |= p & desired;\r\n        // 2) disable the permissions desired on the `target`\r\n        target &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\r\n\r\n        // return calculated result\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if requested set of features is enabled globally on the contract\r\n     *\r\n     * @param required set of features to check against\r\n     * @return true if all the features requested are enabled, false otherwise\r\n     */\r\n    function isFeatureEnabled(uint256 required) public view returns (bool) {\r\n        // delegate call to `__hasRole`, passing `features` property\r\n        return __hasRole(features(), required);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if transaction sender `msg.sender` has all the permissions required\r\n     *\r\n     * @param required set of permissions (role) to check against\r\n     * @return true if all the permissions requested are enabled, false otherwise\r\n     */\r\n    function isSenderInRole(uint256 required) public view returns (bool) {\r\n        // delegate call to `isOperatorInRole`, passing transaction sender\r\n        return isOperatorInRole(msg.sender, required);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if operator has all the permissions (role) required\r\n     *\r\n     * @param operator address of the user to check role for\r\n     * @param required set of permissions (role) to check\r\n     * @return true if all the permissions requested are enabled, false otherwise\r\n     */\r\n    function isOperatorInRole(address operator, uint256 required) public view returns (bool) {\r\n        // delegate call to `__hasRole`, passing operator's permissions (role)\r\n        return __hasRole(userRoles[operator], required);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if role `actual` contains all the permissions required `required`\r\n     *\r\n     * @param actual existent role\r\n     * @param required required role\r\n     * @return true if actual has required role (all permissions), false otherwise\r\n     */\r\n    function __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\r\n        // check the bitmask for the role required and return the result\r\n        return actual & required == required;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc UUPSUpgradeable\r\n     */\r\n    function _authorizeUpgrade(address) internal virtual override {\r\n        // caller must have a permission to upgrade the contract\r\n        require(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/mock/ChainlinkAggregatorV3Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n/**\r\n * @title Chainlink Price Feed Aggregator V3 Mock\r\n *\r\n * @notice Supports the Illuvitars Price Oracle with the ILV/ETH price feed\r\n *\r\n * @dev Enables testing of the feed, playing with current timestamp\r\n *\r\n * @author Basil Gorin\r\n */\r\ncontract ChainlinkAggregatorV3Mock is AggregatorV3Interface {\r\n    // values returned by `latestRoundData()`\r\n    uint80 public roundIdMocked = 1;\r\n    int256 public answerMocked = -1;\r\n    uint256 public startedAtMocked = type(uint256).max;\r\n    uint256 public updatedAtMocked = type(uint256).max;\r\n    uint80 public answeredInRoundMocked = 1;\r\n    // answer (conversion rate) is derived from the ILV/ETH ratio\r\n    // initial conversion rate is 1 ETH = 4 ILV\r\n    uint256 public ethOut = 1;\r\n    uint256 public ilvIn = 4;\r\n\r\n    /// @dev overridden value to use as now32()\r\n    uint256 private _now256;\r\n\r\n    /// @dev overrides now256()\r\n    function setNow256(uint256 value) public {\r\n        _now256 = value;\r\n    }\r\n\r\n    /**\r\n     * @dev Testing time-dependent functionality may be difficult;\r\n     *      we override time in the helper test smart contract (mock)\r\n     *\r\n     * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\r\n     */\r\n    function now256() public view returns (uint256) {\r\n        return _now256 > 0 ? _now256 : block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides roundId, answer, startedAt, updatedAt, answeredInRound\r\n     */\r\n    function setMockedValues(\r\n        uint80 roundId,\r\n        int256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    ) public {\r\n        roundIdMocked = roundId;\r\n        answerMocked = answer;\r\n        startedAtMocked = startedAt;\r\n        updatedAtMocked = updatedAt;\r\n        answeredInRoundMocked = answeredInRound;\r\n    }\r\n\r\n    // updates the conversion rate\r\n    function setRate(uint256 _ethOut, uint256 _ilvIn) public {\r\n        ethOut = _ethOut;\r\n        ilvIn = _ilvIn;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc AggregatorV3Interface\r\n     */\r\n    function decimals() public pure override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc AggregatorV3Interface\r\n     */\r\n    function description() public pure override returns (string memory) {\r\n        return \"ILV / ETH (Mock!)\";\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc AggregatorV3Interface\r\n     */\r\n    function version() public pure override returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc AggregatorV3Interface\r\n     */\r\n    function getRoundData(uint80 _roundId)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        require(_roundId == roundIdMocked, \"roundId differs from the roundId mocked value\");\r\n        return latestRoundData();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc AggregatorV3Interface\r\n     */\r\n    function latestRoundData()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        return (\r\n            roundIdMocked,\r\n            answerMocked >= 0 ? answerMocked : int256((10**decimals() * ethOut) / ilvIn),\r\n            startedAtMocked < type(uint256).max ? startedAtMocked : now256(),\r\n            updatedAtMocked < type(uint256).max ? updatedAtMocked : now256(),\r\n            answeredInRoundMocked\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/PortraitLayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.14;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\r\nimport \"./BaseIlluvitar.sol\";\r\nimport \"./DataTypes.sol\";\r\n\r\n/**\r\n * @title Portrait Layer\r\n * @dev inherit BaseIlluvitar\r\n * @author Dmitry Yakovlevich\r\n */\r\ncontract PortraitLayer is BaseIlluvitar {\r\n    /// @dev Portrait Metadata struct\r\n    struct Metadata {\r\n        BoxType boxType; // box type\r\n        uint8 tier; // tier\r\n        // Bonded accessory token ids\r\n        uint256 skinId; // bonded skin id\r\n        uint256 bodyId; // bonded body id\r\n        uint256 eyeId; // bonded eye wear id\r\n        uint256 headId; // bonded head wear id\r\n        uint256 propsId; // bonded props id\r\n    }\r\n\r\n    /// @dev Portrait metadata\r\n    mapping(uint256 => Metadata) public metadata;\r\n\r\n    /**\r\n     * @dev Initialize Portrait Layer.\r\n     * @param name_ NFT Name\r\n     * @param symbol_ NFT Symbol\r\n     * @param imxMinter_ IMX Minter Address\r\n     */\r\n    function initialize(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address imxMinter_\r\n    ) external initializer {\r\n        __BaseIlluvitar_init(name_, symbol_, imxMinter_);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint Portrait with blueprint.\r\n     * @dev blueprint has format of `ab,c,d,e,f,g`\r\n     *      a : box type\r\n            b : tier\r\n            c : bonded skin id\r\n            d : bonded body id\r\n            e : bonded eye wear id\r\n            f : bonded head wear id\r\n            g : bonded props id\r\n     * @param to Recipient address\r\n     * @param tokenId Token id\r\n     * @param blueprint Portrait blueprint\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory blueprint\r\n    ) internal override {\r\n        _safeMint(to, tokenId);\r\n        if (!metadataInitialized[tokenId]) {\r\n            (\r\n                BoxType boxType,\r\n                uint8 tier,\r\n                uint256 skinTokenId,\r\n                uint256 bodyTokenId,\r\n                uint256 eyeTokenId,\r\n                uint256 headTokenId,\r\n                uint256 propsTokenId\r\n            ) = _parseBlueprint(blueprint);\r\n            metadata[tokenId] = Metadata({\r\n                boxType: boxType,\r\n                tier: tier,\r\n                skinId: skinTokenId,\r\n                bodyId: bodyTokenId,\r\n                eyeId: eyeTokenId,\r\n                headId: headTokenId,\r\n                propsId: propsTokenId\r\n            });\r\n            metadataInitialized[tokenId] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev Parse blueprint\r\n    function _parseBlueprint(bytes memory blueprint)\r\n        private\r\n        pure\r\n        returns (\r\n            BoxType boxType,\r\n            uint8 tier,\r\n            uint256 skinTokenId,\r\n            uint256 bodyTokenId,\r\n            uint256 eyeTokenId,\r\n            uint256 headTokenId,\r\n            uint256 propsTokenId\r\n        )\r\n    {\r\n        uint8 j = 0;\r\n\r\n        uint256 len = blueprint.length;\r\n        uint8 p;\r\n        for (; p < len; p += 1) {\r\n            if (_isDecimal(blueprint[p])) {\r\n                if (j == 0) {\r\n                    boxType = BoxType(uint8(blueprint[p]) - 0x30);\r\n                } else if (j == 1) {\r\n                    tier = uint8(blueprint[p]) - 0x30;\r\n                    p += 1;\r\n                    break;\r\n                }\r\n                j += 1;\r\n            }\r\n        }\r\n\r\n        (skinTokenId, p) = _atoi(blueprint, p);\r\n        (bodyTokenId, p) = _atoi(blueprint, p);\r\n        (eyeTokenId, p) = _atoi(blueprint, p);\r\n        (headTokenId, p) = _atoi(blueprint, p);\r\n        (propsTokenId, p) = _atoi(blueprint, p);\r\n    }\r\n\r\n    /**\r\n     * @dev Simplified version of StringUtils.atoi to convert a bytes string\r\n     *      to unsigned integer using ten as a base\r\n     * @dev Stops on invalid input (wrong character for base ten) and returns\r\n     *      the position within a string where the wrong character was encountered\r\n     *\r\n     * @dev Throws if input string contains a number bigger than uint256\r\n     *\r\n     * @param a numeric string to convert\r\n     * @param offset an index to start parsing from, set to zero to parse from the beginning\r\n     * @return i a number representing given string\r\n     * @return p an index where the conversion stopped\r\n     */\r\n    function _atoi(bytes memory a, uint8 offset) internal pure returns (uint256 i, uint8 p) {\r\n        // skip wrong characters in the beginning of the string if any\r\n        for (p = offset; p < a.length; p++) {\r\n            // check if digit is valid and meets the base 10\r\n            if (_isDecimal(a[p])) {\r\n                // we've found decimal character, skipping stops\r\n                break;\r\n            }\r\n        }\r\n\r\n        // if there weren't any digits found\r\n        if (p == a.length) {\r\n            // just return a zero result\r\n            return (0, offset);\r\n        }\r\n\r\n        // iterate over the rest of the string (bytes buffer)\r\n        for (; p < a.length; p++) {\r\n            // check if digit is valid and meets the base 10\r\n            if (!_isDecimal(a[p])) {\r\n                // we've found bad character, parsing stops\r\n                break;\r\n            }\r\n\r\n            // move to the next digit slot\r\n            i *= 10;\r\n\r\n            // extract the digit and add it to the result\r\n            i += uint8(a[p]) - 0x30;\r\n        }\r\n\r\n        // return the result\r\n        return (i, p);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
